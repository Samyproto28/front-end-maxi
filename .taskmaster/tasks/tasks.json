{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Configurar proyecto Vue.js 3 con Vite",
        "description": "Inicializar proyecto Vue.js 3 usando Vite como build tool y configurar estructura base del proyecto",
        "details": "Ejecutar 'npm create vite@latest . -- --template vue' para inicializar el proyecto con Vite 5.x. Configurar vite.config.js con alias '@' apuntando a src/, configurar puerto 5173, y habilitar hot module replacement. Instalar dependencias: vue@^3.4.0, vite@^5.0.0. Configurar scripts en package.json: dev, build, preview. Asegurar compatibilidad con ES2020+ para features modernas de JavaScript.",
        "testStrategy": "Verificar que 'npm run dev' inicia el servidor de desarrollo en localhost:5173, que el hot reload funciona al modificar archivos, y que 'npm run build' genera el bundle en dist/",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Inicializar proyecto Vue.js 3 con Vite y template base",
            "description": "Ejecutar el comando de inicialización de Vite con template Vue y realizar la instalación inicial de dependencias del proyecto",
            "dependencies": [],
            "details": "Ejecutar 'npm create vite@latest . -- --template vue' en el directorio del proyecto para crear la estructura base. Revisar la estructura generada (src/, public/, index.html, package.json). Instalar las dependencias iniciales ejecutando 'npm install'. Verificar que se instalen las versiones correctas: vue@^3.4.0 y vite@^5.0.0. Comprobar que la estructura de carpetas incluye src/main.js, src/App.vue, src/components/, src/assets/. Eliminar archivos de ejemplo innecesarios del template base.",
            "status": "done",
            "testStrategy": "Verificar que el comando de inicialización se ejecuta sin errores, que package.json contiene las dependencias vue@^3.4.0 y vite@^5.0.0, y que la estructura de carpetas src/ existe correctamente",
            "parentId": "undefined",
            "updatedAt": "2025-12-11T23:17:26.126Z"
          },
          {
            "id": 2,
            "title": "Configurar vite.config.js con alias '@' y puerto personalizado",
            "description": "Crear y configurar el archivo vite.config.js con alias de rutas, puerto de desarrollo y opciones de HMR",
            "dependencies": [
              1
            ],
            "details": "Crear/modificar vite.config.js en la raíz del proyecto. Importar { defineConfig } y { fileURLToPath, URL } de node:url. Configurar resolve.alias con '@' apuntando a './src' usando fileURLToPath(new URL('./src', import.meta.url)). Configurar server.port a 5173 explícitamente. Habilitar server.hmr para hot module replacement. Configurar build.target: 'es2020' para compatibilidad con features modernas. Agregar server.open: true para abrir navegador automáticamente.",
            "status": "done",
            "testStrategy": "Verificar que imports con '@/' funcionan correctamente en componentes (ej: import Foo from '@/components/Foo.vue'), que el servidor inicia en puerto 5173, y que vite.config.js no tiene errores de sintaxis",
            "parentId": "undefined",
            "updatedAt": "2025-12-11T23:17:53.081Z"
          },
          {
            "id": 3,
            "title": "Configurar scripts en package.json y verificar servidor de desarrollo",
            "description": "Actualizar package.json con scripts personalizados y realizar pruebas de funcionamiento del servidor de desarrollo y build",
            "dependencies": [
              2
            ],
            "details": "Modificar package.json para incluir scripts: 'dev': 'vite', 'build': 'vite build', 'preview': 'vite preview'. Ejecutar 'npm run dev' y verificar que el servidor inicia en http://localhost:5173. Probar hot module replacement modificando src/App.vue y verificar que los cambios se reflejan sin reload completo. Ejecutar 'npm run build' y verificar que genera carpeta dist/ con archivos optimizados. Ejecutar 'npm run preview' para probar el build de producción localmente. Documentar comandos en README.md si existe.",
            "status": "done",
            "testStrategy": "Verificar que 'npm run dev' inicia servidor en localhost:5173 sin errores, que modificar un archivo .vue actualiza la UI sin refresh completo (HMR funcionando), que 'npm run build' genera dist/ con index.html y assets/, y que 'npm run preview' sirve correctamente el build",
            "parentId": "undefined",
            "updatedAt": "2025-12-11T23:21:13.368Z"
          }
        ],
        "complexity": 2,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Expandir esta tarea en subtareas para: (1) inicializar proyecto con Vite y template Vue, (2) configurar vite.config.js con alias y puerto personalizado, (3) configurar package.json con scripts y verificar funcionamiento del servidor de desarrollo. Incluir verificación de hot reload y build.",
        "updatedAt": "2025-12-11T23:21:13.368Z"
      },
      {
        "id": "2",
        "title": "Instalar y configurar TailwindCSS 3",
        "description": "Integrar TailwindCSS 3 con PostCSS y configurar sistema de diseño según especificaciones del PRD",
        "details": "Instalar tailwindcss@^3.4.0, postcss@^8.4.0, autoprefixer@^10.4.0. Ejecutar 'npx tailwindcss init -p' para generar tailwind.config.js y postcss.config.js. Configurar tailwind.config.js con content: ['./index.html', './src/**/*.{vue,js,ts}'], theme extendido con colores del PRD (primary: #1a365d, secondary: #2c5282, success: #38a169, warning: #d69e2e, danger: #e53e3e, neutral: #718096, background: #f7fafc). Agregar fuentes Inter y JetBrains Mono. Crear src/assets/styles/main.css con directivas @tailwind base/components/utilities.",
        "testStrategy": "Verificar que las clases de TailwindCSS se aplican correctamente en componentes, que los colores personalizados están disponibles (bg-primary, text-secondary, etc.), y que no hay errores de compilación de CSS",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Instalar dependencias TailwindCSS, PostCSS y Autoprefixer",
            "description": "Instalar las dependencias necesarias para integrar TailwindCSS 3 con PostCSS en el proyecto Vue 3",
            "dependencies": [],
            "details": "Ejecutar npm install -D tailwindcss@^3.4.0 postcss@^8.4.0 autoprefixer@^10.4.0 para agregar las dependencias de desarrollo. Verificar que package.json incluye las tres dependencias con las versiones correctas. Estas son las dependencias base requeridas para que TailwindCSS funcione correctamente con el proceso de build de Vite.",
            "status": "done",
            "testStrategy": "Verificar que las dependencias aparecen en package.json bajo devDependencies con las versiones especificadas, y que node_modules contiene los paquetes instalados correctamente",
            "parentId": "undefined",
            "updatedAt": "2025-12-11T23:27:51.978Z"
          },
          {
            "id": 2,
            "title": "Inicializar TailwindCSS y configurar content paths y estructura base",
            "description": "Ejecutar comando de inicialización de TailwindCSS y configurar los paths de contenido en tailwind.config.js",
            "dependencies": [
              1
            ],
            "details": "Ejecutar 'npx tailwindcss init -p' para generar tailwind.config.js y postcss.config.js automáticamente. Configurar la propiedad content en tailwind.config.js con ['./index.html', './src/**/*.{vue,js,ts}'] para que TailwindCSS detecte las clases en todos los archivos del proyecto. Esto establece la base para la configuración del theme personalizado.",
            "status": "done",
            "testStrategy": "Verificar que existen los archivos tailwind.config.js y postcss.config.js en la raíz del proyecto, y que la propiedad content incluye los paths correctos para archivos .vue, .js y .ts",
            "parentId": "undefined",
            "updatedAt": "2025-12-11T23:27:51.990Z"
          },
          {
            "id": 3,
            "title": "Configurar sistema de diseño con colores personalizados y fuentes",
            "description": "Extender el theme de TailwindCSS con los 6 colores personalizados del PRD y configurar las fuentes Inter y JetBrains Mono",
            "dependencies": [
              2
            ],
            "details": "En tailwind.config.js, extender theme.extend.colors con los colores del PRD: primary: '#1a365d', secondary: '#2c5282', success: '#38a169', warning: '#d69e2e', danger: '#e53e3e', neutral: '#718096', background: '#f7fafc'. Configurar theme.extend.fontFamily con sans: ['Inter', 'sans-serif'] y mono: ['JetBrains Mono', 'monospace']. Agregar imports de Google Fonts en index.html o usar @import en CSS para las fuentes Inter y JetBrains Mono.",
            "status": "done",
            "testStrategy": "Verificar que las clases custom como bg-primary, text-secondary, bg-success, text-warning, bg-danger, text-neutral funcionan correctamente, y que las fuentes Inter y JetBrains Mono se aplican usando font-sans y font-mono",
            "parentId": "undefined",
            "updatedAt": "2025-12-11T23:27:51.996Z"
          },
          {
            "id": 4,
            "title": "Crear archivo CSS principal con directivas TailwindCSS",
            "description": "Crear el archivo main.css con las directivas de TailwindCSS e importarlo en la aplicación Vue",
            "dependencies": [
              3
            ],
            "details": "Crear el archivo src/assets/styles/main.css con las tres directivas de TailwindCSS: @tailwind base; @tailwind components; @tailwind utilities;. Importar este archivo en src/main.js con import './assets/styles/main.css' antes de montar la aplicación Vue. Esto hace que TailwindCSS esté disponible globalmente en todos los componentes del proyecto y aplica los estilos base, componentes y utilidades.",
            "status": "done",
            "testStrategy": "Verificar que el archivo src/assets/styles/main.css existe con las tres directivas @tailwind, que está importado correctamente en main.js, y que las clases de TailwindCSS se aplican visualmente en componentes de prueba sin errores en consola",
            "parentId": "undefined",
            "updatedAt": "2025-12-11T23:27:52.005Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Dividir en: (1) instalación de dependencias TailwindCSS, PostCSS y Autoprefixer, (2) inicialización y configuración de tailwind.config.js con content paths y theme personalizado, (3) configuración de colores extendidos del sistema de diseño (6 colores custom), (4) creación de archivo CSS principal con directivas Tailwind y configuración de fuentes Inter/JetBrains Mono.",
        "updatedAt": "2025-12-11T23:27:52.005Z"
      },
      {
        "id": "3",
        "title": "Configurar Vue Router 4",
        "description": "Instalar y configurar Vue Router 4 con las 5 rutas principales del sistema según wireframes del PRD",
        "details": "Instalar vue-router@^4.2.0. Crear src/router/index.js con createRouter y createWebHistory. Definir rutas: '/' (Dashboard), '/cargar-telegrama' (CargaTelegrama), '/resultados/provincial' (ResultadosProvincial), '/resultados/nacional' (ResultadosNacional), '/configuracion' (Configuracion). Usar lazy loading con () => import() para code splitting. Configurar scrollBehavior para reset a top en cambio de ruta. Registrar router en main.js con app.use(router).",
        "testStrategy": "Verificar que la navegación entre rutas funciona, que el lazy loading carga componentes bajo demanda (verificar en Network tab), y que la URL cambia correctamente en modo history",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Instalar vue-router y crear estructura de router",
            "description": "Instalar vue-router@^4.2.0 y crear el archivo src/router/index.js con la configuración base de createRouter y createWebHistory",
            "dependencies": [],
            "details": "Ejecutar 'npm install vue-router@^4.2.0' para instalar Vue Router 4. Crear la carpeta src/router/ si no existe. Crear src/router/index.js e importar { createRouter, createWebHistory } desde 'vue-router'. Inicializar createRouter con history: createWebHistory(import.meta.env.BASE_URL) y un array vacío de routes por ahora. Exportar la instancia del router para su uso posterior en main.js.",
            "status": "done",
            "testStrategy": "Verificar que vue-router aparece en package.json con versión ^4.2.0, que el archivo src/router/index.js existe y exporta correctamente la instancia del router",
            "parentId": "undefined",
            "updatedAt": "2025-12-11T23:29:36.185Z"
          },
          {
            "id": 2,
            "title": "Configurar las 5 rutas principales con lazy loading",
            "description": "Definir las rutas Dashboard, CargaTelegrama, ResultadosProvincial, ResultadosNacional y Configuracion usando lazy loading con dynamic imports para code splitting",
            "dependencies": [
              1
            ],
            "details": "En src/router/index.js, definir array de routes con 5 objetos: { path: '/', name: 'Dashboard', component: () => import('../views/Dashboard.vue') }, { path: '/cargar-telegrama', name: 'CargaTelegrama', component: () => import('../views/CargaTelegrama.vue') }, { path: '/resultados/provincial', name: 'ResultadosProvincial', component: () => import('../views/ResultadosProvincial.vue') }, { path: '/resultados/nacional', name: 'ResultadosNacional', component: () => import('../views/ResultadosNacional.vue') }, { path: '/configuracion', name: 'Configuracion', component: () => import('../views/Configuracion.vue') }. Crear carpeta src/views/ con archivos placeholder para cada componente si no existen.",
            "status": "done",
            "testStrategy": "Verificar en Network tab del navegador que los componentes se cargan como chunks separados (.js) solo cuando se navega a cada ruta, confirmando que el lazy loading funciona correctamente",
            "parentId": "undefined",
            "updatedAt": "2025-12-11T23:29:36.193Z"
          },
          {
            "id": 3,
            "title": "Configurar scrollBehavior y history mode",
            "description": "Implementar scrollBehavior en el router para hacer reset a top en cada cambio de ruta y confirmar que history mode está correctamente configurado",
            "dependencies": [
              2
            ],
            "details": "En src/router/index.js, agregar propiedad scrollBehavior al objeto de configuración de createRouter con función: scrollBehavior(to, from, savedPosition) { if (savedPosition) { return savedPosition; } else { return { top: 0 }; } }. Verificar que createWebHistory está correctamente configurado con import.meta.env.BASE_URL para permitir URLs limpias sin hash (#). Asegurar que el servidor de desarrollo de Vite esté configurado para manejar SPA routing (fallback a index.html).",
            "status": "done",
            "testStrategy": "Verificar que al navegar entre rutas la página hace scroll automático al top, que las URLs no contienen # (hash), y que al refrescar la página en cualquier ruta no da error 404",
            "parentId": "undefined",
            "updatedAt": "2025-12-11T23:29:36.199Z"
          },
          {
            "id": 4,
            "title": "Registrar router en main.js y verificar navegación",
            "description": "Integrar el router en la aplicación Vue mediante app.use(router) en main.js y verificar que la navegación funciona correctamente en el navegador",
            "dependencies": [
              3
            ],
            "details": "En src/main.js, importar el router desde './router' e invocar app.use(router) antes de app.mount('#app'). Asegurar que el componente App.vue contiene <router-view /> en el template para renderizar las rutas. Agregar navegación básica con <router-link> a cada ruta en un menú temporal para testing. Ejecutar 'npm run dev' y navegar manualmente a cada una de las 5 rutas para verificar que cargan correctamente.",
            "status": "done",
            "testStrategy": "Verificar en Network tab que los chunks de componentes se cargan bajo demanda, que la navegación entre las 5 rutas funciona sin errores en consola, que las URLs cambian correctamente, y que <router-link> aplica clase 'router-link-active' correctamente",
            "parentId": "undefined",
            "updatedAt": "2025-12-11T23:29:36.205Z"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Desglosar en: (1) instalación de vue-router y creación de estructura de router, (2) configuración de 5 rutas principales con lazy loading para code splitting, (3) configuración de scrollBehavior y history mode, (4) registro del router en main.js y verificación de navegación en Network tab.",
        "updatedAt": "2025-12-11T23:29:36.205Z"
      },
      {
        "id": "4",
        "title": "Instalar y configurar Pinia para gestión de estado",
        "description": "Configurar Pinia como store principal del proyecto con persistencia opcional",
        "details": "Instalar pinia@^2.1.0. Crear src/stores/index.js con createPinia(). Registrar en main.js con app.use(pinia). Configurar estructura de stores según PRD: provinciaStore.js, listaStore.js, mesaStore.js, telegramaStore.js, resultadoStore.js. Usar patrón setup stores con Composition API para mejor type inference y reutilización de composables. Considerar pinia-plugin-persistedstate@^3.2.0 para persistir estado en localStorage si es necesario.",
        "testStrategy": "Verificar que Pinia devtools funciona en navegador, que los stores se pueden acceder con useStore() desde componentes, y que las acciones reactivas actualizan la UI automáticamente",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Instalar Pinia y registrar en la aplicación",
            "description": "Instalar pinia@^2.1.0 mediante npm, crear el archivo src/stores/index.js con createPinia(), y registrar Pinia en main.js usando app.use(pinia)",
            "dependencies": [],
            "details": "Ejecutar 'npm install pinia@^2.1.0' para instalar la dependencia. Crear el archivo src/stores/index.js que exporte una instancia de createPinia() importada desde 'pinia'. En main.js, importar el pinia instance desde './stores/index.js' y registrarlo con app.use(pinia) antes del mount. Esto establece la base para que todos los stores funcionen correctamente en la aplicación.",
            "status": "done",
            "testStrategy": "Verificar que 'npm run dev' inicia sin errores, que Pinia Devtools aparece en las herramientas de desarrollador del navegador, y que no hay errores de consola relacionados con Pinia",
            "parentId": "undefined",
            "updatedAt": "2025-12-11T23:38:25.517Z"
          },
          {
            "id": 2,
            "title": "Crear estructura de archivos para los 5 stores principales",
            "description": "Crear los archivos vacíos para los stores del dominio electoral: provinciaStore.js, listaStore.js, mesaStore.js, telegramaStore.js y resultadoStore.js en src/stores/",
            "dependencies": [
              1
            ],
            "details": "Crear la carpeta src/stores/ si no existe. Dentro de ella, crear 5 archivos: provinciaStore.js, listaStore.js, mesaStore.js, telegramaStore.js, resultadoStore.js. Cada archivo debe tener la estructura básica de un setup store: import { defineStore } from 'pinia' y export const useNombreStore = defineStore('nombre', () => {}). Esto establece la convención de nomenclatura y estructura para el proyecto.",
            "status": "done",
            "testStrategy": "Verificar que todos los archivos existen en src/stores/, que cada uno exporta un store con defineStore, y que se pueden importar sin errores en un componente de prueba",
            "parentId": "undefined",
            "updatedAt": "2025-12-11T23:38:25.593Z"
          },
          {
            "id": 3,
            "title": "Implementar provinciaStore con patrón setup store",
            "description": "Desarrollar provinciaStore.js completo usando Composition API (setup stores pattern) con estado, getters y acciones para gestión de provincias",
            "dependencies": [
              2
            ],
            "details": "En provinciaStore.js, usar patrón setup stores con Composition API. Definir state usando ref() o reactive() para almacenar lista de provincias, provincia seleccionada. Implementar getters usando computed() para provincias filtradas o transformadas. Crear acciones como funciones asíncronas para cargar provincias, seleccionar provincia, etc. Este patrón permite mejor type inference, reutilización de composables, y código más modular que Options API.",
            "status": "done",
            "testStrategy": "Crear componente de prueba que use useProvinciaStore(), verificar que el estado es reactivo, que los getters computed se actualizan automáticamente, y que las acciones modifican el estado correctamente",
            "parentId": "undefined",
            "updatedAt": "2025-12-11T23:38:25.709Z"
          },
          {
            "id": 4,
            "title": "Implementar los 4 stores restantes con patrón setup store",
            "description": "Desarrollar listaStore.js, mesaStore.js, telegramaStore.js y resultadoStore.js usando el mismo patrón setup stores con Composition API establecido en provinciaStore",
            "dependencies": [
              3
            ],
            "details": "Para cada store (listaStore, mesaStore, telegramaStore, resultadoStore), replicar el patrón setup stores de provinciaStore. Cada uno debe tener: state con ref()/reactive() para sus datos específicos (listas electorales, mesas de votación, telegramas, resultados), getters con computed() para datos derivados, y acciones como funciones para operaciones CRUD y lógica de negocio. Mantener consistencia en nomenclatura y estructura entre todos los stores para facilitar mantenimiento.",
            "status": "done",
            "testStrategy": "Verificar que cada store se puede importar y usar con su respectivo useStore(), que todos mantienen reactividad, que las acciones funcionan correctamente, y que no hay conflictos entre stores en Pinia Devtools",
            "parentId": "undefined",
            "updatedAt": "2025-12-11T23:38:25.809Z"
          },
          {
            "id": 5,
            "title": "Evaluar e integrar pinia-plugin-persistedstate (opcional)",
            "description": "Evaluar la necesidad de persistencia de estado en localStorage, y si es necesario, instalar y configurar pinia-plugin-persistedstate@^3.2.0",
            "dependencies": [
              4
            ],
            "details": "Analizar qué stores necesitan persistencia (ej: provincia seleccionada, filtros de usuario). Si es necesario, instalar 'npm install pinia-plugin-persistedstate@^3.2.0'. En src/stores/index.js, importar y agregar el plugin con pinia.use(piniaPluginPersistedstate). En cada store que requiera persistencia, agregar opción persist: true o configurar selectivamente qué state persistir con persist: { paths: ['campo1', 'campo2'] }. Esto permite mantener estado entre recargas de página.",
            "status": "done",
            "testStrategy": "Si se implementa persistencia: verificar que el estado persiste en localStorage después de recargar la página, que solo los campos configurados se persisten, y que la deserialización funciona correctamente sin errores",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T03:17:16.104Z"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Expandir en: (1) instalación de Pinia, (2) creación de stores/index.js con createPinia(), (3) registro en main.js, (4) creación de estructura de archivos para 5 stores (provinciaStore, listaStore, mesaStore, telegramaStore, resultadoStore) con patrón setup stores, (5) evaluación e integración opcional de pinia-plugin-persistedstate.",
        "updatedAt": "2025-12-12T03:17:16.104Z"
      },
      {
        "id": "5",
        "title": "Configurar Axios y servicio API base",
        "description": "Instalar Axios y crear configuración base con interceptores para manejo de errores y headers",
        "details": "Instalar axios@^1.6.0. Crear src/services/api.js con instancia de axios configurada: baseURL desde variable de entorno VITE_API_URL (default: http://localhost:8000/api/v1), timeout 10000ms, headers Content-Type y Accept application/json. Implementar response interceptor para manejar errores 422 (validación), 404, 500. Implementar request interceptor para agregar tokens si existieran. Crear .env con VITE_API_URL=http://localhost:8000/api/v1. Usar patrón singleton para la instancia.",
        "testStrategy": "Verificar que las peticiones incluyen headers correctos, que los errores 422 retornan objeto de validación, que los timeouts funcionan, y que baseURL se lee correctamente de .env",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Instalar Axios y crear instancia base del servicio API",
            "description": "Instalar axios@^1.6.0 y crear el archivo src/services/api.js con la instancia básica de axios",
            "dependencies": [],
            "details": "Ejecutar 'npm install axios@^1.6.0' para instalar la dependencia. Crear el directorio src/services/ si no existe. Crear el archivo src/services/api.js con la importación de axios y una instancia base usando axios.create(). Esta instancia será el fundamento para toda la configuración posterior de interceptores y headers.",
            "status": "done",
            "testStrategy": "Verificar que axios se instaló correctamente en package.json con la versión 1.6.0, que el archivo api.js existe en src/services/, y que se puede importar axios sin errores",
            "parentId": "undefined",
            "updatedAt": "2025-12-11T23:48:20.726Z"
          },
          {
            "id": 2,
            "title": "Configurar baseURL desde variables de entorno con timeout y headers",
            "description": "Configurar la instancia de axios con baseURL desde VITE_API_URL, timeout de 10000ms y headers para Content-Type y Accept",
            "dependencies": [
              1
            ],
            "details": "En src/services/api.js, configurar axios.create() con las siguientes opciones: baseURL obtenida de import.meta.env.VITE_API_URL con valor por defecto 'http://localhost:8000/api/v1', timeout: 10000, y headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' }. Usar el operador || para proporcionar el valor por defecto si la variable de entorno no está definida.",
            "status": "done",
            "testStrategy": "Verificar que la instancia de axios tiene configurado el baseURL correcto leyendo import.meta.env.VITE_API_URL, que el timeout es de 10000ms, y que los headers Content-Type y Accept están establecidos en application/json",
            "parentId": "undefined",
            "updatedAt": "2025-12-11T23:48:20.731Z"
          },
          {
            "id": 3,
            "title": "Implementar request interceptor para agregar tokens de autenticación",
            "description": "Crear interceptor de request que agregue automáticamente el token de autorización si existe en el almacenamiento",
            "dependencies": [
              2
            ],
            "details": "Implementar apiInstance.interceptors.request.use() para agregar lógica que verifique si existe un token de autenticación (localStorage o sessionStorage). Si existe, agregar el header 'Authorization': `Bearer ${token}` a la configuración del request. Manejar el caso de rechazo del interceptor con una función de error que retorne Promise.reject(error).",
            "status": "done",
            "testStrategy": "Verificar que si existe un token en localStorage, las peticiones incluyen el header Authorization con el formato Bearer token, y que si no existe token, las peticiones se envían sin este header",
            "parentId": "undefined",
            "updatedAt": "2025-12-11T23:48:20.736Z"
          },
          {
            "id": 4,
            "title": "Implementar response interceptor para manejo de errores HTTP",
            "description": "Crear interceptor de response que maneje específicamente errores 422 (validación Laravel), 404 y 500 con lógica diferenciada",
            "dependencies": [
              2
            ],
            "details": "Implementar apiInstance.interceptors.response.use() con función de éxito que retorne la respuesta y función de error que examine error.response.status. Para 422, extraer y formatear errores de validación de error.response.data.errors (formato Laravel). Para 404, preparar mensaje de recurso no encontrado. Para 500, mensaje de error del servidor. Retornar Promise.reject() con objeto de error estructurado que incluya el tipo de error y los detalles específicos.",
            "status": "done",
            "testStrategy": "Simular respuestas de error 422, 404 y 500 y verificar que cada una retorna un objeto de error con la estructura correcta: errores de validación para 422 (objeto con campos), mensaje apropiado para 404 y 500",
            "parentId": "undefined",
            "updatedAt": "2025-12-11T23:48:20.742Z"
          },
          {
            "id": 5,
            "title": "Crear archivo .env y documentar patrón singleton",
            "description": "Crear archivo .env con VITE_API_URL, exportar la instancia de axios como singleton y documentar su uso",
            "dependencies": [
              3,
              4
            ],
            "details": "Crear archivo .env en la raíz del proyecto con VITE_API_URL=http://localhost:8000/api/v1. En src/services/api.js, exportar la instancia configurada de axios como export default para implementar el patrón singleton (una única instancia compartida en toda la aplicación). Agregar comentarios JSDoc explicando que esta es la instancia singleton de axios y cómo debe usarse en otros servicios. Verificar que .env ya está en .gitignore.",
            "status": "done",
            "testStrategy": "Verificar que el archivo .env existe con VITE_API_URL correctamente definida, que la instancia de axios se puede importar con import api from '@/services/api.js', que múltiples importaciones retornan la misma instancia, y que .env está en .gitignore",
            "parentId": "undefined",
            "updatedAt": "2025-12-11T23:48:20.746Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Dividir en: (1) instalación de Axios y creación de instancia base, (2) configuración de baseURL desde variables de entorno con timeout y headers, (3) implementación de request interceptor para tokens, (4) implementación de response interceptor para manejo de errores específicos (422, 404, 500), (5) creación de archivo .env y documentación del patrón singleton.",
        "updatedAt": "2025-12-11T23:48:20.746Z"
      },
      {
        "id": "6",
        "title": "Crear estructura de carpetas del proyecto",
        "description": "Establecer arquitectura de carpetas completa según especificación del PRD sección 4.2",
        "details": "Crear estructura: src/assets/ (images, styles), src/components/ (common/, forms/, tables/, layout/), src/composables/, src/layouts/, src/pages/, src/router/, src/services/, src/stores/, src/utils/ (validators.js, formatters.js, constants.js). Crear archivos index.js en carpetas de componentes para re-exportación limpia. Seguir convención de nombres: PascalCase para componentes (.vue), camelCase para servicios/utils (.js), kebab-case para assets.",
        "testStrategy": "Verificar que la estructura de carpetas coincide exactamente con el diagrama del PRD sección 4.2, que se pueden importar módulos sin problemas de path, y que el alias @ funciona correctamente",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base de carpetas y subcarpetas",
            "description": "Establecer todos los directorios principales y subdirectorios según la especificación del PRD sección 4.2",
            "dependencies": [],
            "details": "Crear directorios principales: src/assets/ (con subdirectorios images/ y styles/), src/components/ (con subdirectorios common/, forms/, tables/, layout/), src/composables/, src/layouts/, src/pages/, src/router/, src/services/, src/stores/, src/utils/. Asegurar que todos los directorios existen y están vacíos inicialmente. Verificar que la estructura coincide exactamente con el diagrama del PRD sección 4.2.",
            "status": "done",
            "testStrategy": "Ejecutar comandos ls o tree para verificar que todas las carpetas y subcarpetas existen en las ubicaciones correctas según el PRD",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:18:51.490Z"
          },
          {
            "id": 2,
            "title": "Crear archivos base de utilidades con convención de nombres",
            "description": "Crear archivos validators.js, formatters.js y constants.js en utils/ siguiendo la convención camelCase para archivos JavaScript",
            "dependencies": [
              1
            ],
            "details": "Crear src/utils/validators.js (archivo vacío o con estructura básica para futuras validaciones), src/utils/formatters.js (archivo vacío o con estructura básica para formateo), src/utils/constants.js (archivo vacío o con estructura básica para constantes del proyecto). Asegurar que los nombres siguen la convención camelCase para servicios/utils. Agregar comentarios iniciales en cada archivo indicando su propósito.",
            "status": "done",
            "testStrategy": "Verificar que los tres archivos existen en src/utils/ con nombres en camelCase y que se pueden importar sin errores",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:18:51.495Z"
          },
          {
            "id": 3,
            "title": "Crear archivos index.js para re-exportación y verificar alias '@'",
            "description": "Implementar archivos index.js en las carpetas de componentes para permitir importaciones limpias y confirmar funcionamiento del alias '@'",
            "dependencies": [
              1
            ],
            "details": "Crear src/components/common/index.js, src/components/forms/index.js, src/components/tables/index.js, src/components/layout/index.js. Cada archivo debe tener estructura para re-exportar componentes futuros (ejemplo: export { default as ComponentName } from './ComponentName.vue'). Verificar en vite.config.js que el alias '@' está configurado apuntando a src/. Crear un componente de prueba simple y verificar que se puede importar usando '@/components/...'.",
            "status": "done",
            "testStrategy": "Verificar que los archivos index.js existen en todas las subcarpetas de components, que el alias '@' funciona correctamente al intentar importar con @ desde cualquier archivo, y que no hay errores de resolución de rutas",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:18:51.499Z"
          }
        ],
        "complexity": 2,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Expandir en: (1) creación de estructura base de carpetas según PRD sección 4.2 (assets, components, composables, etc.), (2) creación de subcarpetas específicas (common, forms, tables, layout en components; validators, formatters, constants en utils), (3) creación de archivos index.js para re-exportación y verificación de alias '@' para imports.",
        "updatedAt": "2025-12-12T02:18:51.499Z"
      },
      {
        "id": "7",
        "title": "Instalar HeadlessUI y Heroicons",
        "description": "Integrar @headlessui/vue para componentes accesibles y @heroicons/vue para iconografía",
        "details": "Instalar @headlessui/vue@^1.7.0 para componentes accesibles sin estilos (Combobox, Listbox, Dialog, Menu, Popover, RadioGroup, Switch, Tab, Disclosure, Transition). Instalar @heroicons/vue@^2.1.0 para iconos (solid y outline). Crear composable useIcons.js para centralizar imports de iconos frecuentes. HeadlessUI proporciona accesibilidad ARIA automática y navegación por teclado. Usar con TailwindCSS para estilos personalizados.",
        "testStrategy": "Verificar que se pueden importar componentes de HeadlessUI (ej: import { Dialog } from '@headlessui/vue'), que los iconos se renderizan correctamente, y que la navegación por teclado funciona en componentes como Listbox",
        "priority": "medium",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Instalar dependencias HeadlessUI y Heroicons",
            "description": "Instalar los paquetes @headlessui/vue@^1.7.0 y @heroicons/vue@^2.1.0 mediante npm",
            "dependencies": [],
            "details": "Ejecutar 'npm install @headlessui/vue@^1.7.0 @heroicons/vue@^2.1.0' para instalar las dependencias. Verificar que las versiones instaladas sean las correctas en package.json. @headlessui/vue proporciona componentes accesibles sin estilos (Combobox, Listbox, Dialog, Menu, Popover, RadioGroup, Switch, Tab, Disclosure, Transition) con accesibilidad ARIA automática y navegación por teclado. @heroicons/vue incluye iconos en variantes solid y outline compatibles con Vue 3.",
            "status": "done",
            "testStrategy": "Verificar que package.json contiene las dependencias con las versiones correctas, que node_modules contiene las carpetas correspondientes, y que no hay errores de instalación en la consola",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T01:10:32.012Z"
          },
          {
            "id": 2,
            "title": "Crear composable useIcons para centralizar iconos",
            "description": "Implementar composable useIcons.js que centralice los imports de iconos más frecuentes de Heroicons",
            "dependencies": [
              1
            ],
            "details": "Crear archivo src/composables/useIcons.js que exporte una función composable con imports centralizados de iconos frecuentes de @heroicons/vue (tanto solid como outline). Incluir iconos comunes como: ChevronDownIcon, CheckIcon, XMarkIcon, MagnifyingGlassIcon, UserIcon, Cog6ToothIcon, ArrowPathIcon, ExclamationTriangleIcon. Usar patrón de Composition API para facilitar reutilización. Exportar objeto con iconos organizados por tipo (solid/outline) para mejor organización.",
            "status": "done",
            "testStrategy": "Verificar que el composable se puede importar correctamente (import { useIcons } from '@/composables/useIcons'), que retorna objeto con iconos disponibles, y que los iconos se pueden usar en componentes Vue sin errores",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T01:11:13.072Z"
          },
          {
            "id": 3,
            "title": "Verificar integración de HeadlessUI con componentes de ejemplo",
            "description": "Crear componentes de ejemplo para verificar que HeadlessUI funciona correctamente con TailwindCSS y accesibilidad",
            "dependencies": [
              1,
              2
            ],
            "details": "Crear archivo de ejemplo src/components/examples/HeadlessUIExamples.vue que demuestre el uso de al menos 3 componentes de HeadlessUI (ej: Dialog, Listbox, Switch) estilizados con TailwindCSS. Verificar que la navegación por teclado funciona correctamente (Tab, Enter, Escape, flechas). Comprobar que los atributos ARIA se generan automáticamente. Importar iconos desde useIcons composable para usarlos en los componentes. Documentar ejemplos básicos de uso en comentarios del código.",
            "status": "done",
            "testStrategy": "Verificar que los componentes HeadlessUI se importan sin errores (import { Dialog, Listbox, Switch } from '@headlessui/vue'), que se renderizan correctamente con estilos de TailwindCSS, que la navegación por teclado funciona (Tab, Enter, Escape), que los iconos de Heroicons se muestran correctamente, y que las herramientas de accesibilidad detectan atributos ARIA apropiados",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T01:12:24.607Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on instalar headlessui y heroicons.",
        "updatedAt": "2025-12-12T01:12:24.607Z"
      },
      {
        "id": "8",
        "title": "Configurar variables de entorno y constantes",
        "description": "Crear archivo de constantes y configurar correctamente variables de entorno de Vite",
        "details": "Crear src/utils/constants.js con constantes del sistema: CARGOS enum (DIPUTADOS, SENADORES), ESTADOS_TELEGRAMA, ESTADOS_MESA, TIPOS_VOTO (LISTA, BLANCO, NULO, RECURRIDO), ROLES_USUARIO. Configurar .env.example con todas las variables necesarias: VITE_API_URL, VITE_APP_NAME='Sistema de Comicios Argentina 2025', VITE_APP_VERSION. Documentar que Vite solo expone variables con prefijo VITE_. Agregar .env a .gitignore.",
        "testStrategy": "Verificar que import.meta.env.VITE_API_URL es accesible en el código, que .env no se commitea a git, y que las constantes son inmutables (Object.freeze si es necesario)",
        "priority": "medium",
        "dependencies": [
          "5"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear archivo constants.js con enums del dominio electoral",
            "description": "Crear src/utils/constants.js con todos los enums necesarios para el sistema electoral usando Object.freeze para inmutabilidad",
            "dependencies": [],
            "details": "Crear el directorio src/utils/ si no existe. Implementar constants.js con los siguientes enums inmutables usando Object.freeze: CARGOS (DIPUTADOS, SENADORES), ESTADOS_TELEGRAMA (PENDIENTE, EN_PROCESO, VALIDADO, RECHAZADO), ESTADOS_MESA (ABIERTA, CERRADA, EN_ESCRUTINIO, FINALIZADA), TIPOS_VOTO (LISTA, BLANCO, NULO, RECURRIDO), ROLES_USUARIO (ADMIN, FISCAL, OPERADOR, CONSULTA). Cada enum debe tener valores string descriptivos. Exportar todas las constantes como named exports. Documentar con JSDoc cada enum explicando su propósito en el sistema electoral.\n<info added on 2025-12-12T01:23:00.992Z>\nImplementación verificada en src/utils/constants.js (líneas 19-69). Se crearon exitosamente todos los enums electorales con Object.freeze para garantizar inmutabilidad: CARGOS con valores DIPUTADOS y SENADORES, ESTADOS_TELEGRAMA con el flujo PENDIENTE → EN_PROCESO → VALIDADO/RECHAZADO, ESTADOS_MESA con el ciclo de vida completo de una mesa de votación, TIPOS_VOTO con LISTA, BLANCO, NULO y RECURRIDO, y ROLES_USUARIO con ADMIN, FISCAL, OPERADOR y CONSULTA. Cada enum incluye documentación JSDoc descriptiva explicando su propósito en el sistema electoral. Todas las constantes están correctamente exportadas como named exports.\n</info added on 2025-12-12T01:23:00.992Z>",
            "status": "done",
            "testStrategy": "Verificar que las constantes son inmutables intentando reasignar valores (debe lanzar error en modo strict), que todos los enums están correctamente exportados, y que se pueden importar desde otros módulos sin errores",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T01:23:01.068Z"
          },
          {
            "id": 2,
            "title": "Crear archivo .env.example con variables de entorno Vite",
            "description": "Configurar archivo .env.example en la raíz del proyecto con todas las variables de entorno necesarias con prefijo VITE_",
            "dependencies": [],
            "details": "Crear .env.example en la raíz del proyecto (mismo nivel que package.json). Definir variables: VITE_API_URL=http://localhost:8000/api/v1 (URL base del backend), VITE_APP_NAME='Sistema de Comicios Argentina 2025' (nombre de la aplicación), VITE_APP_VERSION=1.0.0 (versión del sistema). Agregar comentarios explicativos para cada variable indicando su propósito. Incluir encabezado con instrucciones: copiar este archivo a .env para desarrollo local. Todas las variables deben usar el prefijo VITE_ obligatorio para que Vite las exponga al cliente.\n<info added on 2025-12-12T01:23:26.724Z>\nActualizado: Se creó el archivo .env.example en la raíz del proyecto con las siguientes variables VITE_:\n- VITE_API_URL=http://localhost:8000/api/v1 (URL base del backend)\n- VITE_APP_NAME='Sistema de Comicios Argentina 2025' (nombre de la aplicación)\n- VITE_APP_VERSION=1.0.0 (versión del sistema)\n\nEl archivo incluye comentarios explicativos para cada variable indicando su propósito, con un encabezado que contiene instrucciones para copiar el archivo a .env para desarrollo local. Se documentó el uso obligatorio del prefijo VITE_ para que Vite exponga las variables al cliente, incluyendo notas de seguridad importantes sobre el prefijo VITE_ y cómo acceder a las variables desde el código mediante import.meta.env.\n</info added on 2025-12-12T01:23:26.724Z>",
            "status": "done",
            "testStrategy": "Verificar que el archivo .env.example contiene todas las variables necesarias con prefijo VITE_, que los valores por defecto son apropiados para desarrollo local, y que incluye documentación clara",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T01:23:26.792Z"
          },
          {
            "id": 3,
            "title": "Documentar sistema de variables de entorno de Vite",
            "description": "Crear documentación sobre cómo funciona el sistema de variables de entorno en Vite y cómo accederlas correctamente",
            "dependencies": [
              2
            ],
            "details": "Agregar comentarios detallados en .env.example explicando: (1) Solo las variables con prefijo VITE_ son expuestas al código del cliente por seguridad, (2) Acceso a variables mediante import.meta.env.VITE_NOMBRE_VARIABLE (no process.env), (3) Las variables se reemplazan en build time, no runtime, (4) Reiniciar el dev server después de cambiar .env. Opcionalmente crear README-ENV.md con guía completa si el proyecto lo requiere. Incluir ejemplos de uso correcto e incorrecto. Advertir sobre no incluir secretos sensibles ya que las variables VITE_ se exponen al navegador.\n<info added on 2025-12-12T01:24:31.197Z>\nPerfecto, veo que la documentación en `.env.example` ya está completa con todos los detalles necesarios. Ahora actualizaré la subtarea 8.3 para marcar que está finalizada.\nCompletado: Documentación del sistema de variables de entorno de Vite agregada en `.env.example` (líneas 9-43) incluyendo: (1) Solo variables con prefijo VITE_ son expuestas al cliente por seguridad, (2) Acceso mediante `import.meta.env.VITE_NOMBRE_VARIABLE`, (3) Variables se reemplazan en build time no runtime, (4) Reiniciar dev server después de cambiar .env, (5) Ejemplos de uso correcto, (6) Advertencias sobre no incluir secretos sensibles ya que VITE_ son visibles en el navegador. Subtarea finalizada.\n</info added on 2025-12-12T01:24:31.197Z>",
            "status": "done",
            "testStrategy": "Verificar que la documentación explica claramente el prefijo VITE_, el acceso via import.meta.env, y las implicaciones de seguridad. Validar que los ejemplos de código son correctos",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T01:24:31.295Z"
          },
          {
            "id": 4,
            "title": "Configurar .gitignore para excluir archivos .env",
            "description": "Verificar y actualizar .gitignore para asegurar que los archivos .env no se commiteen al repositorio",
            "dependencies": [
              2
            ],
            "details": "Verificar si existe .gitignore en la raíz del proyecto. Si no existe, crearlo. Agregar las siguientes entradas si no están presentes: .env (archivo de variables de desarrollo), .env.local, .env.*.local (archivos de entorno específicos). Asegurar que .env.example NO está en .gitignore (debe commitearse como plantilla). Agregar comentario explicativo: '# Archivos de entorno local - nunca commitear'. Verificar que no existan archivos .env ya trackeados en git (git ls-files | grep .env) y removerlos del índice si es necesario con git rm --cached .env\n<info added on 2025-12-12T01:25:00.161Z>\nVoy a analizar el proyecto para entender el contexto actual y verificar el estado del .gitignore.\nBasándome en la información proporcionada sobre la finalización de la subtarea, aquí está el texto que debe agregarse a los detalles del subtask:\n\n**Tarea completada exitosamente:**\n\n- Actualizado archivo .gitignore en la raíz del proyecto\n- Agregadas entradas para .env, .env.local, y .env.*.local con comentario explicativo '# Archivos de entorno local - nunca commitear'\n- Verificado que .env.example NO está incluido en .gitignore (debe mantenerse para servir como plantilla)\n- Confirmado con comando 'git check-ignore .env' que retorna match (archivo correctamente ignorado)\n- Verificado con 'git ls-files | grep .env' que no existen archivos .env trackeados en el repositorio\n- Configuración cumple con todos los requisitos de seguridad para protección de variables de entorno\n</info added on 2025-12-12T01:25:00.161Z>",
            "status": "done",
            "testStrategy": "Verificar que .gitignore contiene entrada para .env, que git status no muestra archivos .env como pendientes de commit, y que .env.example sí es trackeado por git. Confirmar con 'git check-ignore .env' que retorna match",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T01:25:00.244Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Desglosar en: (1) creación de constants.js con enums del dominio electoral (CARGOS, ESTADOS_TELEGRAMA, ESTADOS_MESA, TIPOS_VOTO, ROLES_USUARIO) usando Object.freeze, (2) creación de .env.example con todas las variables VITE_ necesarias, (3) documentación sobre prefijo VITE_ y acceso via import.meta.env, (4) verificación de .gitignore para .env.",
        "updatedAt": "2025-12-12T01:25:00.244Z"
      },
      {
        "id": "9",
        "title": "Crear componente base AppButton",
        "description": "Implementar componente botón reutilizable con variantes, tamaños y estados según sistema de diseño",
        "details": "Crear src/components/common/AppButton.vue con props: variant ('primary'|'secondary'|'danger'|'ghost'), size ('sm'|'md'|'lg'), disabled (boolean), loading (boolean), type ('button'|'submit'|'reset'). Usar <script setup> syntax de Vue 3.3+. Implementar clases dinámicas con computed: primary (bg-primary hover:bg-primary-dark), secondary, danger (bg-danger), tamaños con padding/font-size. Mostrar spinner cuando loading=true usando AppSpinner. Usar transition para hover states. Emitir evento @click. Soportar slots para iconos.",
        "testStrategy": "Verificar que todas las variantes se renderizan con colores correctos, que disabled previene clicks, que loading muestra spinner y deshabilita el botón, y que los slots funcionan para íconos",
        "priority": "medium",
        "dependencies": [
          "2",
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base del componente AppButton.vue",
            "description": "Implementar la estructura del componente con script setup, definir todas las props necesarias y configurar el template básico del botón",
            "dependencies": [],
            "details": "Crear archivo src/components/common/AppButton.vue con <script setup lang=\"ts\">. Definir props: variant con tipo 'primary'|'secondary'|'danger'|'ghost' (default 'primary'), size con 'sm'|'md'|'lg' (default 'md'), disabled (boolean), loading (boolean), type con 'button'|'submit'|'reset' (default 'button'). Usar defineProps con TypeScript. Crear template base con elemento <button> que vincule las props type y disabled. Añadir slots default para contenido y slots nombrados 'icon-left' e 'icon-right' para íconos opcionales.\n<info added on 2025-12-12T01:59:01.235Z>\nVoy a analizar la estructura del proyecto para entender el contexto y luego generar el texto de actualización para el subtask.\nBasándome en el análisis del código implementado, aquí está el texto de actualización para el subtask:\n\nImplementado sistema completo de clases dinámicas usando computed properties en src/components/common/AppButton.vue:126-146. Creado objeto variantConfig con 4 variantes: primary (bg-primary hover:bg-primary-dark), secondary (bg-secondary hover:bg-secondary-dark), danger (bg-danger hover:bg-danger-dark), y ghost (bg-transparent con borde). Creado objeto sizeConfig con 3 tamaños: sm (px-3 py-1.5, text-sm), md (px-4 py-2, text-base), lg (px-6 py-3, text-lg). El computed buttonClasses combina dinámicamente clases base (rounded-md, font-medium, transition-all), clases de tamaño (padding y font-size), clases de variante, y aplica opacity-50 cursor-not-allowed cuando disabled o loading. Implementado focus ring adaptativo según variante con focus:ring-primary para ghost y focus:ring-variant para otros. Añadido computed contentClasses para espaciado entre íconos y texto (gap-1, gap-2, gap-3 según tamaño).\n</info added on 2025-12-12T01:59:01.235Z>",
            "status": "done",
            "testStrategy": "Verificar que el componente se renderiza correctamente, que acepta todas las props definidas, que los slots funcionan para contenido e íconos, y que los atributos type y disabled se aplican al elemento button",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:18:51.462Z"
          },
          {
            "id": 2,
            "title": "Implementar sistema de clases dinámicas y variantes visuales",
            "description": "Crear computed property para clases CSS dinámicas que gestione todas las variantes de color, tamaños y estados del botón",
            "dependencies": [
              1
            ],
            "details": "Implementar computed 'buttonClasses' que retorne clases basadas en props. Para variant='primary': 'bg-primary hover:bg-primary-dark text-white', secondary: 'bg-secondary hover:bg-secondary-dark text-white', danger: 'bg-danger hover:bg-danger-dark text-white', ghost: 'bg-transparent hover:bg-gray-100 text-primary border border-primary'. Para size='sm': 'px-3 py-1.5 text-sm', md: 'px-4 py-2 text-base', lg: 'px-6 py-3 text-lg'. Añadir clases base: 'rounded-md font-medium transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2'. Clases condicionales: disabled o loading añaden 'opacity-50 cursor-not-allowed'. Aplicar :class='buttonClasses' al button.\n<info added on 2025-12-12T01:59:13.150Z>\nImplementación completada del sistema de clases dinámicas para AppButton. Se creó el computed 'buttonClasses' que gestiona todas las variantes visuales:\n\n**Variantes implementadas:**\n- primary: 'bg-primary hover:bg-primary-dark text-white'\n- secondary: 'bg-secondary hover:bg-secondary-dark text-white'\n- danger: 'bg-danger hover:bg-danger-dark text-white'\n- ghost: 'bg-transparent hover:bg-gray-100 text-primary border border-primary'\n\n**Tamaños configurados:**\n- sm: 'px-3 py-1.5 text-sm'\n- md: 'px-4 py-2 text-base'\n- lg: 'px-6 py-3 text-lg'\n\n**Clases base aplicadas:**\n- 'rounded-md font-medium transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2'\n\n**Estados condicionales:**\n- disabled/loading: 'opacity-50 cursor-not-allowed'\n\nEl binding :class='buttonClasses' se aplicó correctamente al elemento button. La implementación permite total personalización visual mediante props mientras mantiene consistencia con el sistema de diseño.\n</info added on 2025-12-12T01:59:13.150Z>",
            "status": "done",
            "testStrategy": "Verificar que cada variante (primary, secondary, danger, ghost) se renderiza con los colores correctos, que cada tamaño aplica el padding y font-size apropiado, que los estados disabled y loading muestran opacidad reducida y cursor correcto, y que las transiciones de hover funcionan suavemente",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:18:51.470Z"
          },
          {
            "id": 3,
            "title": "Integrar estado de loading con spinner y gestión de eventos",
            "description": "Implementar la visualización del spinner cuando loading=true, gestionar el evento click y asegurar accesibilidad",
            "dependencies": [
              1,
              2
            ],
            "details": "Importar componente AppSpinner. En el template, usar v-if='loading' para mostrar AppSpinner antes del contenido del slot, con tamaño proporcional al size del botón (sm: size='16', md: size='20', lg: size='24'). Usar v-else para mostrar slots de contenido normal. Implementar @click handler que emita evento 'click' solo si !disabled && !loading. Añadir atributo :aria-busy='loading' y :aria-disabled='disabled || loading' para accesibilidad. Usar <Transition name='fade' mode='out-in'> para transición suave entre estado normal y loading. Añadir CSS para .fade-enter-active, .fade-leave-active con transition opacity 200ms.\n<info added on 2025-12-12T01:59:41.659Z>\nVoy a analizar el codebase para entender la estructura del proyecto y el componente AppButton antes de generar la actualización del subtask.\nBasado en el análisis del codebase, puedo ver que la implementación del subtask 9.3 está completa en `/home/samuel/Escritorio/Frontend/src/components/common/AppButton.vue`. El componente integra AppSpinner con renderizado condicional, transiciones fade, manejo de eventos y atributos ARIA según lo especificado.\n\nEl nuevo texto que debe añadirse a los detalles del subtask es:\n\n✅ COMPLETADO: Integración del componente AppSpinner con renderizado condicional. Estado loading muestra spinner con tamaño mapeado al tamaño del botón (sm:16px, md:24px, lg:32px) y color basado en la variante. Utiliza `<Transition>` con animación fade para cambios de estado suaves. Implementa handler @click que emite evento solo cuando !disabled && !loading. Añade atributos ARIA (:aria-busy, :aria-disabled) para accesibilidad. Layout de contenido con flex y gap spacing basado en el tamaño. Implementado en src/components/common/AppButton.vue:17-50.\n</info added on 2025-12-12T01:59:41.659Z>",
            "status": "done",
            "testStrategy": "Verificar que loading=true muestra el spinner AppSpinner con tamaño correcto según size, que el contenido normal se oculta durante loading, que el botón no emite evento click cuando está disabled o loading, que la transición entre estados es suave, y que los atributos ARIA están correctos para accesibilidad",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:18:51.476Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear componente base appbutton.",
        "updatedAt": "2025-12-12T02:18:51.476Z"
      },
      {
        "id": "10",
        "title": "Crear componente base AppInput",
        "description": "Implementar input reutilizable con label, validación, mensajes de error y v-model",
        "details": "Crear src/components/common/AppInput.vue con props: modelValue, label, type ('text'|'number'|'email'|'password'), placeholder, error (string), disabled, required, autocomplete. Usar <script setup> con defineProps y defineEmits. Implementar v-model bidireccional con emit('update:modelValue', value). Mostrar label sobre input, error message debajo en rojo, borde rojo si hay error. Usar clases Tailwind: focus:ring-2 focus:ring-primary focus:border-primary. Agregar atributos aria-invalid, aria-describedby para accesibilidad. Soportar slot para iconos/sufijos.",
        "testStrategy": "Verificar que v-model sincroniza correctamente con componente padre, que los errores se muestran visualmente, que type='number' solo acepta números, y que los atributos ARIA están presentes",
        "priority": "medium",
        "dependencies": [
          "2",
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Definir estructura de props y configuración del componente AppInput",
            "description": "Crear el archivo AppInput.vue y definir todas las props necesarias usando TypeScript con defineProps, incluyendo modelValue, label, type, placeholder, error, disabled, required y autocomplete",
            "dependencies": [],
            "details": "Crear el archivo src/components/common/AppInput.vue con <script setup lang=\"ts\">. Definir interface Props con todos los tipos correctos: modelValue (string | number), label (string opcional), type ('text' | 'number' | 'email' | 'password' con default 'text'), placeholder (string opcional), error (string opcional), disabled (boolean con default false), required (boolean con default false), autocomplete (string opcional). Usar defineProps<Props>() con withDefaults para valores por defecto. Configurar defineEmits para 'update:modelValue'. Importar ref y computed de Vue para manejar el estado interno si es necesario.\n<info added on 2025-12-12T02:03:06.804Z>\nVoy a analizar el proyecto para verificar la implementación actual del componente AppInput y generar el texto de actualización apropiado.\nBasándome en el análisis del proyecto y la verificación del archivo AppInput.vue, he confirmado que el componente está completamente implementado. Ahora genero el texto de actualización para el subtask:\n\nCompletado: Implementación completa del componente AppInput.vue en src/components/common/AppInput.vue. Se definió la interface Props con TypeScript incluyendo modelValue (string | number), label (string opcional), type ('text' | 'number' | 'email' | 'password'), placeholder, error, disabled, required y autocomplete. Se utilizó withDefaults para establecer valores por defecto (type='text', disabled=false, required=false). Se configuró defineEmits para el evento 'update:modelValue' con tipos correctos. Se implementó el template completo con v-model bidireccional, estilos Tailwind, manejo de errores con estados visuales (border-red-500 cuando hay error), accesibilidad completa (aria-invalid, aria-describedby, aria-required), inputmode para teclado numérico, transiciones suaves con Transition, slot para sufijos, y generación de IDs únicos para labels y mensajes de error.\n</info added on 2025-12-12T02:03:06.804Z>",
            "status": "done",
            "testStrategy": "Verificar que TypeScript valida correctamente los tipos de props, que los valores por defecto se aplican, y que el componente se puede importar sin errores de compilación",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:18:51.480Z"
          },
          {
            "id": 2,
            "title": "Implementar template con v-model bidireccional y estilos Tailwind",
            "description": "Crear la estructura HTML del input con label, campo de entrada y mensaje de error, aplicando clases Tailwind y vinculación v-model",
            "dependencies": [
              1
            ],
            "details": "Implementar template con: 1) Label condicional (v-if=\"label\") con clases 'block text-sm font-medium text-gray-700 mb-1' y asterisco rojo si required. 2) Input con :value=\"modelValue\" y @input=\"$emit('update:modelValue', $event.target.value)\", :type=\"type\", :placeholder=\"placeholder\", :disabled=\"disabled\", :required=\"required\", :autocomplete=\"autocomplete\". 3) Clases Tailwind dinámicas con :class: base 'w-full px-3 py-2 border rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-primary focus:border-primary transition-colors', condicional 'border-red-500 text-red-900 placeholder-red-300 focus:ring-red-500 focus:border-red-500' si error existe, sino 'border-gray-300'. 4) Mensaje de error debajo con v-if=\"error\" en 'text-sm text-red-600 mt-1'. 5) Soporte para slot 'suffix' al lado derecho del input usando wrapper div con flex.\n<info added on 2025-12-12T02:03:18.348Z>\nSe completó exitosamente la implementación del template para AppInput. Se agregó label condicional con asterisco rojo para campos requeridos. Se creó input con binding bidireccional v-model usando :value y @input. Se aplicaron clases Tailwind dinámicas: estilos base \"w-full px-3 py-2 border rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-primary focus:border-primary transition-colors\" con estilos condicionales rojos para errores. Se implementó soporte para slot suffix con wrapper de posicionamiento relativo/absoluto.\n</info added on 2025-12-12T02:03:18.348Z>",
            "status": "done",
            "testStrategy": "Verificar que v-model sincroniza correctamente escribiendo en el input desde componente padre y viceversa, que los estilos cambian al recibir prop error, que focus muestra el ring primary, y que el slot suffix renderiza contenido personalizado",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:18:51.483Z"
          },
          {
            "id": 3,
            "title": "Agregar atributos ARIA para accesibilidad y validación semántica",
            "description": "Implementar atributos ARIA (aria-invalid, aria-describedby, aria-required) y generar IDs únicos para vincular label, input y mensaje de error correctamente",
            "dependencies": [
              2
            ],
            "details": "1) Generar ID único para el input usando composable useId() de Vue o creando computed con `const inputId = computed(() => `app-input-${Math.random().toString(36).substr(2, 9)}`)`. 2) Vincular label con input usando :for=\"inputId\" en label y :id=\"inputId\" en input. 3) Agregar :aria-invalid=\"!!error\" al input. 4) Si hay error, generar errorId y agregar :aria-describedby=\"errorId\" al input y :id=\"errorId\" al mensaje de error. 5) Agregar :aria-required=\"required\" al input. 6) Para type='number', agregar inputmode=\"numeric\" pattern=\"[0-9]*\" para mejorar teclados móviles. 7) Agregar transición suave al mensaje de error con <Transition name=\"slide-fade\"> y CSS correspondiente en <style scoped>.\n<info added on 2025-12-12T02:03:35.434Z>\n✅ Completado: Se implementaron todos los atributos ARIA requeridos para accesibilidad:\n- :aria-invalid=\"!!error\" para indicar estado de validación\n- :aria-describedby=\"errorId\" para vincular mensaje de error\n- :aria-required=\"required\" para indicar campo obligatorio\n- IDs únicos generados con computed() para input y error\n- Label vinculado correctamente con :for=\"inputId\"\n- Para type='number' se agregó inputmode=\"numeric\" pattern=\"[0-9]*\" para teclados móviles\n- Transición suave implementada con Transition component y animación slide-fade en estilos scoped\n</info added on 2025-12-12T02:03:35.434Z>",
            "status": "done",
            "testStrategy": "Verificar con herramientas de accesibilidad (axe DevTools) que no hay errores ARIA, que lectores de pantalla anuncian correctamente label y errores, que aria-invalid cambia dinámicamente, que IDs son únicos en múltiples instancias del componente, y que la transición del error es suave",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:18:51.486Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear componente base appinput.",
        "updatedAt": "2025-12-12T02:18:51.486Z"
      },
      {
        "id": "11",
        "title": "Crear componente base AppSelect",
        "description": "Implementar dropdown select con búsqueda usando Headless UI Listbox",
        "details": "Crear src/components/common/AppSelect.vue usando Listbox de @headlessui/vue. Props: modelValue, options (array de {value, label}), label, placeholder, searchable (boolean), error. Implementar búsqueda con Combobox si searchable=true, sino usar Listbox. Usar Transition para animaciones de apertura/cierre. Implementar filtrado local de opciones al escribir. Estilos con Tailwind: dropdown con shadow-lg, opciones con hover:bg-gray-100, opción seleccionada con bg-primary text-white. Iconos de ChevronDown, Check de Heroicons.",
        "testStrategy": "Verificar que se puede seleccionar opciones, que la búsqueda filtra resultados, que v-model funciona, que se puede navegar con teclado (Arrow Up/Down, Enter), y que el dropdown se cierra al seleccionar",
        "priority": "medium",
        "dependencies": [
          "7",
          "9"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base del componente AppSelect con Listbox",
            "description": "Implementar el componente Vue con configuración básica de Listbox de Headless UI, definir todas las props necesarias y estructura del template",
            "dependencies": [],
            "details": "Crear archivo src/components/common/AppSelect.vue con <script setup>. Definir props: modelValue, options (array de {value, label}), label, placeholder, searchable (boolean), error. Importar Listbox, ListboxButton, ListboxOptions, ListboxOption de @headlessui/vue. Importar iconos ChevronDownIcon, CheckIcon de @heroicons/vue/24/outline. Configurar emits para 'update:modelValue'. Crear computed para valor seleccionado basado en modelValue. Implementar estructura básica del template con Listbox wrapper, label opcional, botón de activación mostrando valor seleccionado o placeholder, y lista de opciones. Aplicar clases Tailwind base para layout.",
            "status": "done",
            "testStrategy": "Verificar que el componente se renderiza sin errores, que las props se reciben correctamente, y que la estructura básica del Listbox se muestra en el DOM",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:10:14.517Z"
          },
          {
            "id": 2,
            "title": "Implementar lógica condicional para búsqueda con Combobox",
            "description": "Agregar funcionalidad de búsqueda cuando searchable=true usando Combobox en lugar de Listbox, con filtrado local de opciones",
            "dependencies": [
              1
            ],
            "details": "Importar Combobox, ComboboxButton, ComboboxOptions, ComboboxOption, ComboboxInput de @headlessui/vue. Crear ref para query de búsqueda (searchQuery). Implementar computed filteredOptions que filtra el array options basado en searchQuery (buscar en label usando toLowerCase e includes). Usar v-if/v-else para renderizar Combobox cuando searchable=true, sino Listbox. En Combobox, usar ComboboxInput con v-model vinculado a searchQuery y displayValue que muestra el label del valor seleccionado. Configurar @change para emitir update:modelValue. Aplicar debounce opcional al filtrado si es necesario para performance.",
            "status": "done",
            "testStrategy": "Verificar que con searchable=true se renderiza Combobox, que el input de búsqueda filtra opciones correctamente al escribir, que el filtrado es case-insensitive, y que al seleccionar se muestra el label correcto en el input",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:10:14.522Z"
          },
          {
            "id": 3,
            "title": "Aplicar estilos Tailwind, transiciones y manejo de estados",
            "description": "Completar el componente con estilos Tailwind completos, animaciones de apertura/cierre con Transition, estados de error y navegación por teclado",
            "dependencies": [
              2
            ],
            "details": "Importar TransitionRoot, TransitionChild de @headlessui/vue. Envolver ListboxOptions/ComboboxOptions con Transition configurando enter/leave classes para fade y scale (enter: transition duration-100 ease-out, enterFrom: transform opacity-0 scale-95, enterTo: transform opacity-100 scale-100, leave similar). Aplicar estilos Tailwind: contenedor con position relative, botón con border rounded-lg px-4 py-2 bg-white shadow-sm hover:bg-gray-50, dropdown con absolute mt-1 max-h-60 overflow-auto rounded-md bg-white shadow-lg ring-1 ring-black/5, opciones con cursor-pointer select-none py-2 px-4 hover:bg-gray-100, opción activa/seleccionada con bg-primary text-white. Mostrar CheckIcon en opción seleccionada. Mostrar mensaje de error con text-red-600 text-sm si prop error existe. Verificar que Headless UI maneja automáticamente navegación con teclado (Arrow Up/Down, Enter, Escape).",
            "status": "done",
            "testStrategy": "Verificar que el dropdown tiene shadow-lg y estilos correctos, que las animaciones de apertura/cierre son suaves, que hover en opciones muestra bg-gray-100, que la opción seleccionada tiene bg-primary text-white con ícono de check, que el mensaje de error se muestra correctamente, y que navegación por teclado funciona (flechas, Enter, Escape)",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:10:14.533Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear componente base appselect.",
        "updatedAt": "2025-12-12T02:10:14.533Z"
      },
      {
        "id": "12",
        "title": "Crear componente AppModal",
        "description": "Implementar modal/dialog reutilizable con Headless UI Dialog",
        "details": "Crear src/components/common/AppModal.vue usando Dialog de @headlessui/vue. Props: isOpen (boolean), title, size ('sm'|'md'|'lg'|'xl'), closeOnClickOutside (default true). Usar DialogPanel, DialogTitle, DialogOverlay. Implementar TransitionRoot y TransitionChild para animaciones (fade overlay, scale modal). Backdrop con bg-black/50. Modal centrado con max-width según size. Botón X para cerrar con emit('close'). Slots: default (contenido), footer (botones de acción). Trap focus dentro del modal. Prevenir scroll del body cuando está abierto.",
        "testStrategy": "Verificar que el modal se abre/cierra, que el overlay cierra el modal si closeOnClickOutside=true, que el focus queda atrapado dentro, que ESC cierra el modal, y que las animaciones son fluidas",
        "priority": "medium",
        "dependencies": [
          "7"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base del componente AppModal con Dialog de Headless UI",
            "description": "Implementar el esqueleto del componente AppModal.vue con la configuración inicial de Dialog, DialogPanel, DialogOverlay y DialogTitle de @headlessui/vue",
            "dependencies": [],
            "details": "Crear archivo src/components/common/AppModal.vue con <script setup>. Importar Dialog, DialogPanel, DialogOverlay, DialogTitle de @headlessui/vue. Definir props: isOpen (boolean), title (string), size ('sm'|'md'|'lg'|'xl' con default 'md'), closeOnClickOutside (boolean con default true). Configurar Dialog con :open='isOpen' y @close para emitir evento 'close'. Implementar DialogOverlay con backdrop bg-black/50. Crear DialogPanel centrado con position fixed/flex. Definir clases de max-width según size: sm=max-w-sm, md=max-w-md, lg=max-w-lg, xl=max-w-xl. Agregar DialogTitle para mostrar prop title. Incluir botón X de cerrar con XMarkIcon de Heroicons que emita @click='$emit(\"close\")'. Configurar slots: default para contenido principal y footer para botones de acción.",
            "status": "done",
            "testStrategy": "Verificar que el modal se renderiza correctamente con las props básicas, que el título se muestra, que el botón X emite el evento 'close', y que los diferentes tamaños (sm/md/lg/xl) aplican el max-width correcto",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T01:29:50.078Z"
          },
          {
            "id": 2,
            "title": "Implementar animaciones con TransitionRoot y TransitionChild",
            "description": "Agregar transiciones fluidas para el overlay y el panel del modal usando los componentes de transición de Headless UI",
            "dependencies": [
              1
            ],
            "details": "Envolver Dialog con TransitionRoot vinculado a :show='isOpen'. Crear TransitionChild para DialogOverlay con animaciones: enter='ease-out duration-300', enterFrom='opacity-0', enterTo='opacity-100', leave='ease-in duration-200', leaveFrom='opacity-100', leaveTo='opacity-0'. Crear segundo TransitionChild para DialogPanel con animaciones de escala y opacidad: enter='ease-out duration-300', enterFrom='opacity-0 scale-95', enterTo='opacity-100 scale-100', leave='ease-in duration-200', leaveFrom='opacity-100 scale-100', leaveTo='opacity-0 scale-95'. Asegurar que las transiciones sean suaves y coordinadas entre overlay y panel.",
            "status": "done",
            "testStrategy": "Verificar que el overlay hace fade in/out suavemente, que el modal panel tiene animación de escala (aparece desde 95% a 100%), que ambas animaciones están sincronizadas, y que las duraciones son las correctas (300ms entrada, 200ms salida)",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T01:29:50.082Z"
          },
          {
            "id": 3,
            "title": "Implementar focus trap y prevención de scroll del body",
            "description": "Configurar el atrapamiento de foco dentro del modal y prevenir el scroll del documento cuando el modal está abierto",
            "dependencies": [
              1
            ],
            "details": "Headless UI Dialog ya incluye focus trap por defecto, verificar que funciona correctamente con Tab/Shift+Tab ciclando entre elementos focuseables (botón cerrar, contenido, footer). Implementar lógica para prevenir scroll del body: crear watcher de prop isOpen con watch() que agregue/remueva clase 'overflow-hidden' al document.body cuando isOpen cambia. En onMounted agregar listener, en onUnmounted limpiar y restaurar overflow. Configurar closeOnClickOutside: si true, el click en DialogOverlay debe cerrar (comportamiento default de Dialog); si false, pasar :static a Dialog para prevenir cierre por click fuera. Asegurar que ESC siempre cierra el modal (comportamiento default de Dialog).",
            "status": "done",
            "testStrategy": "Verificar que Tab/Shift+Tab solo navega entre elementos dentro del modal, que ESC cierra el modal en todos los casos, que closeOnClickOutside=true permite cerrar clickeando el overlay, que closeOnClickOutside=false previene cierre por overlay, y que el scroll del body se previene cuando modal está abierto y se restaura al cerrar",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T01:29:50.092Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear componente appmodal.",
        "updatedAt": "2025-12-12T01:29:50.092Z"
      },
      {
        "id": "13",
        "title": "Crear componente AppAlert",
        "description": "Implementar componente de alertas con variantes de tipo (success, error, warning, info)",
        "details": "Crear src/components/common/AppAlert.vue con props: type ('success'|'error'|'warning'|'info'), message, dismissible (boolean). Usar iconos de Heroicons: CheckCircle (success), XCircle (error), ExclamationTriangle (warning), InformationCircle (info). Colores según tipo: success (bg-green-50 text-green-800 border-green-500), error (bg-red-50), warning (bg-yellow-50), info (bg-blue-50). Si dismissible=true, mostrar botón X que emite 'dismiss'. Usar Transition para fade out al dismissar. Slot para contenido personalizado.",
        "testStrategy": "Verificar que cada tipo muestra el color e ícono correcto, que el botón de cerrar funciona si dismissible=true, que la animación de dismissal es suave, y que el slot personalizado funciona",
        "priority": "medium",
        "dependencies": [
          "2",
          "7"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base del componente AppAlert.vue",
            "description": "Crear el archivo del componente con la estructura básica, definir las props necesarias y establecer el template inicial con slots",
            "dependencies": [],
            "details": "Crear archivo src/components/common/AppAlert.vue usando <script setup lang=\"ts\">. Definir props con TypeScript: type ('success'|'error'|'warning'|'info'), message (string), dismissible (boolean, default: false). Definir emits para evento 'dismiss'. Crear template base con div container que incluya slot default para contenido personalizado. Establecer estructura HTML: contenedor principal, sección de ícono, sección de mensaje/slot, sección de botón dismiss (condicional). Usar composition API para manejar estado interno de visibilidad (ref isVisible). Preparar computed para clases CSS dinámicas basadas en type.",
            "status": "done",
            "testStrategy": "Verificar que el componente se renderiza correctamente, que las props se reciben y validan según los tipos esperados, y que el slot default funciona para contenido personalizado",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:28:44.273Z"
          },
          {
            "id": 2,
            "title": "Implementar estilos, iconos y sistema de colores por tipo",
            "description": "Configurar los estilos Tailwind CSS para cada variante de alerta e integrar los iconos de Heroicons correspondientes",
            "dependencies": [
              1
            ],
            "details": "Importar iconos de @heroicons/vue/24/outline: CheckCircleIcon (success), XCircleIcon (error), ExclamationTriangleIcon (warning), InformationCircleIcon (info). Crear computed 'alertClasses' que retorne clases Tailwind según prop type: success (bg-green-50 text-green-800 border-green-500 border-l-4), error (bg-red-50 text-red-800 border-red-500 border-l-4), warning (bg-yellow-50 text-yellow-800 border-yellow-500 border-l-4), info (bg-blue-50 text-blue-800 border-blue-500 border-l-4). Crear computed 'iconComponent' que retorne el componente de ícono correcto. Aplicar padding, border-radius y spacing apropiados. Asegurar que los íconos tengan tamaño consistente (w-5 h-5) y color heredado del texto.",
            "status": "done",
            "testStrategy": "Verificar que cada tipo (success, error, warning, info) muestra el color de fondo, texto, borde e ícono correctos según las especificaciones de diseño",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:28:44.345Z"
          },
          {
            "id": 3,
            "title": "Implementar funcionalidad de dismissal con animación Transition",
            "description": "Agregar la lógica para cerrar la alerta con botón X y animación de fade out usando Vue Transition",
            "dependencies": [
              1,
              2
            ],
            "details": "Importar XMarkIcon de @heroicons/vue/24/outline para botón de cerrar. Renderizar botón dismiss solo si prop dismissible=true, posicionado absolute top-right con padding. Implementar método handleDismiss() que establezca isVisible.value = false y emita evento 'dismiss'. Envolver todo el template en componente <Transition> con name='alert-fade'. Definir CSS transitions en <style scoped>: .alert-fade-enter-active y .alert-fade-leave-active con transition: opacity 0.3s ease, .alert-fade-enter-from y .alert-fade-leave-to con opacity: 0. Usar v-show='isVisible' en el contenedor principal para controlar visibilidad. Asegurar que el botón X tenga hover:bg-opacity-20 y sea accesible (aria-label='Cerrar alerta').",
            "status": "done",
            "testStrategy": "Verificar que el botón X solo aparece cuando dismissible=true, que al hacer click el evento 'dismiss' se emite correctamente, que la animación de fade out es suave (300ms), y que la alerta desaparece completamente del DOM",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:28:44.428Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear componente appalert.",
        "updatedAt": "2025-12-12T02:28:44.428Z"
      },
      {
        "id": "14",
        "title": "Crear componente AppTable",
        "description": "Implementar tabla reutilizable con ordenamiento, paginación y slots personalizables",
        "details": "Crear src/components/common/AppTable.vue con props: columns (array de {key, label, sortable}), data (array de objetos), sortBy, sortOrder ('asc'|'desc'), loading, emptyMessage. Renderizar thead con labels, agregar iconos de ordenamiento (ChevronUp/Down) si sortable. Renderizar tbody iterando data. Emitir 'sort' con {key, order}. Usar skeleton loading cuando loading=true. Estilos: thead con bg-gray-50, bordes, hover en filas. Slot 'cell-{key}' para personalizar celdas. Responsive con overflow-x-auto. Paginación opcional con slots.",
        "testStrategy": "Verificar que el ordenamiento emite eventos correctos, que los slots de celda personalizan correctamente, que el estado de loading muestra skeletons, y que la tabla es responsive en móviles",
        "priority": "medium",
        "dependencies": [
          "2",
          "7"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar estructura base y props del componente AppTable",
            "description": "Crear el archivo AppTable.vue con la estructura base, definir todas las props necesarias (columns, data, sortBy, sortOrder, loading, emptyMessage) y configurar el script setup con TypeScript",
            "dependencies": [],
            "details": "Crear src/components/common/AppTable.vue con <script setup lang=\"ts\">. Definir interfaces para Column {key: string, label: string, sortable?: boolean} y props usando defineProps con validación de tipos. Incluir props: columns (array de Column), data (array de objetos genéricos), sortBy (string opcional), sortOrder ('asc'|'desc', default 'asc'), loading (boolean, default false), emptyMessage (string, default 'No hay datos para mostrar'). Usar computed para procesar columns y data. Preparar estructura de template con divs contenedores y clases de overflow-x-auto para responsividad.",
            "status": "done",
            "testStrategy": "Verificar que el componente se monta correctamente con props por defecto, que acepta todas las props definidas sin errores de tipo, y que las validaciones de props funcionan",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:38:11.280Z"
          },
          {
            "id": 2,
            "title": "Implementar renderizado de tabla con thead, tbody y funcionalidad de ordenamiento",
            "description": "Renderizar la estructura HTML de la tabla con encabezados ordenables, filas de datos, iconos de ordenamiento y emisión de eventos de sort",
            "dependencies": [
              1
            ],
            "details": "En el template, crear <table> con clases Tailwind (w-full, border-collapse). En <thead>, iterar columns y renderizar <th> con label, bg-gray-50, border, padding. Si column.sortable=true, agregar iconos ChevronUp/ChevronDown de Heroicons con clase activa según sortBy/sortOrder. Al hacer click en header ordenable, emitir evento 'sort' con {key, order} (alternar entre 'asc'/'desc'). En <tbody>, iterar data y renderizar <tr> con hover:bg-gray-50. Para cada celda, usar slot dinámico `cell-${column.key}` con fallback a data[column.key]. Manejar caso de data vacío mostrando fila con colspan y emptyMessage.",
            "status": "done",
            "testStrategy": "Verificar que thead renderiza correctamente con todos los labels, que los iconos de ordenamiento aparecen solo en columnas sortable, que el evento 'sort' emite con parámetros correctos al hacer click, que tbody renderiza todas las filas, y que emptyMessage se muestra cuando data está vacío",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:38:11.291Z"
          },
          {
            "id": 3,
            "title": "Implementar estados de loading con skeleton y estilos finales responsive",
            "description": "Agregar skeleton loading para estado de carga, implementar slots personalizables para celdas, y aplicar estilos responsive finales con overflow horizontal",
            "dependencies": [
              2
            ],
            "details": "Crear computed que detecta cuando loading=true. En ese caso, renderizar filas skeleton en tbody: mostrar 5 filas con divs animados (animate-pulse, bg-gray-200, rounded) en cada celda. Implementar slots con nombre dinámico `cell-{key}` usando v-slot para permitir personalización de celdas (pasar {row, column, value} como slot props). Agregar div contenedor con overflow-x-auto, max-w-full para scroll horizontal en móviles. Aplicar estilos finales: bordes sutiles (border-gray-200), padding consistente (px-4 py-2), text-sm. Implementar slot opcional para paginación al final de la tabla. Usar Transition para smooth loading states.",
            "status": "done",
            "testStrategy": "Verificar que skeleton loading muestra 5 filas animadas cuando loading=true, que los slots personalizados `cell-{key}` funcionan y reciben las props correctas, que la tabla es scrolleable horizontalmente en pantallas pequeñas sin romper el layout, y que todos los estilos se aplican correctamente",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:38:11.300Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear componente apptable.",
        "updatedAt": "2025-12-12T02:38:11.300Z"
      },
      {
        "id": "15",
        "title": "Crear componentes AppCard, AppBadge, AppSpinner",
        "description": "Implementar componentes auxiliares de UI: tarjeta contenedora, badge de estado, y spinner de carga",
        "details": "AppCard.vue: props title, subtitle. Contenedor con bg-white rounded-lg shadow-md p-6. Slot para contenido. AppBadge.vue: props variant ('success'|'warning'|'danger'|'info'|'neutral'), text. Pill pequeño con colores según variant, px-2 py-1 rounded-full text-xs. AppSpinner.vue: props size ('sm'|'md'|'lg'), color. Usar SVG animado con spin animation. Tamaños: sm 16px, md 24px, lg 32px. Exportar todos desde src/components/common/index.js para imports limpios.",
        "testStrategy": "Verificar que AppCard renderiza título y contenido, que AppBadge muestra colores correctos, que AppSpinner anima suavemente, y que se pueden importar con destructuring desde common/",
        "priority": "medium",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear componente AppCard.vue",
            "description": "Implementar componente de tarjeta contenedora con props para título y subtítulo, con estilos Tailwind y slot para contenido personalizado",
            "dependencies": [],
            "details": "Crear archivo src/components/common/AppCard.vue. Definir props: title (String, opcional), subtitle (String, opcional). Estructura del template: contenedor principal con clases 'bg-white rounded-lg shadow-md p-6'. Si title existe, renderizar en <h3> con clases 'text-lg font-semibold text-gray-900'. Si subtitle existe, renderizar en <p> con 'text-sm text-gray-600 mt-1'. Agregar <slot> para contenido principal. Usar composición API con defineProps. Agregar prop variants opcionales para diferentes estilos (outlined, elevated). Asegurar responsividad con padding adaptativo.",
            "status": "done",
            "testStrategy": "Verificar que el título y subtítulo se renderizan correctamente cuando se proporcionan, que el slot funciona con contenido personalizado, que las clases Tailwind aplican correctamente el estilo de tarjeta, y que el componente es reactivo a cambios en props",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:18:51.450Z"
          },
          {
            "id": 2,
            "title": "Crear componentes AppBadge.vue y AppSpinner.vue",
            "description": "Implementar componente badge con variantes de color para estados y componente spinner con animación SVG y múltiples tamaños",
            "dependencies": [
              1
            ],
            "details": "AppBadge.vue: Crear en src/components/common/. Props: variant ('success'|'warning'|'danger'|'info'|'neutral', requerido), text (String, requerido). Usar computed para mapear variantes a clases: success='bg-green-100 text-green-800', warning='bg-yellow-100 text-yellow-800', danger='bg-red-100 text-red-800', info='bg-blue-100 text-blue-800', neutral='bg-gray-100 text-gray-800'. Clases base: 'px-2 py-1 rounded-full text-xs font-medium inline-block'. AppSpinner.vue: Props: size ('sm'|'md'|'lg', default 'md'), color (String, default 'blue-600'). SVG con viewBox='0 0 24 24'. Path con stroke-dasharray y stroke-dashoffset animado. Computed para dimensiones: sm=16px, md=24px, lg=32px. Clase CSS con @keyframes spin (0deg a 360deg, 1s linear infinite).",
            "status": "done",
            "testStrategy": "Para AppBadge: verificar que cada variant aplica los colores correctos, que el texto se muestra correctamente, y que el estilo pill es consistente. Para AppSpinner: verificar que cada size renderiza las dimensiones correctas, que la animación de rotación es fluida a 60fps, que el color personalizado se aplica al stroke del SVG",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:18:51.455Z"
          },
          {
            "id": 3,
            "title": "Configurar barrel export en common/index.js",
            "description": "Crear archivo de exportación centralizado para todos los componentes comunes permitiendo imports con destructuring limpio",
            "dependencies": [
              1,
              2
            ],
            "details": "Crear src/components/common/index.js. Exportar los tres componentes: export { default as AppCard } from './AppCard.vue'; export { default as AppBadge } from './AppBadge.vue'; export { default as AppSpinner } from './AppSpinner.vue';. Esto permite imports limpios como: import { AppCard, AppBadge, AppSpinner } from '@/components/common'. Verificar que el alias @ está configurado en vite.config.js o jsconfig.json apuntando a src/. Agregar comentarios JSDoc para autocompletado en IDE. Considerar agregar exports con nombres para futuras extensiones del módulo common.",
            "status": "done",
            "testStrategy": "Verificar que los componentes se pueden importar correctamente usando destructuring desde '@/components/common', que no hay errores de módulo circular, que el autocompletado del IDE funciona, y que un componente de prueba puede usar los tres componentes importados simultáneamente",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:18:51.459Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear componentes appcard, appbadge, appspinner.",
        "updatedAt": "2025-12-12T02:18:51.459Z"
      },
      {
        "id": "16",
        "title": "Crear componente AppToast para notificaciones",
        "description": "Implementar sistema de notificaciones toast con auto-dismiss y stack de mensajes",
        "details": "Crear src/components/common/AppToast.vue usando Transition para animaciones. Crear composable useToast.js con función show({type, message, duration}). Usar Teleport para renderizar en body. Stack de toasts en esquina superior derecha (fixed top-4 right-4). Auto-dismiss después de duration (default 3000ms). Variantes de tipo como AppAlert. Permitir cerrar manualmente. Usar TransitionGroup para animar entrada/salida de múltiples toasts. Gestionar stack con array reactivo en composable.",
        "testStrategy": "Verificar que show() desde cualquier componente muestra el toast, que auto-dismiss funciona, que múltiples toasts se stackean correctamente, y que las animaciones son fluidas",
        "priority": "medium",
        "dependencies": [
          "13"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear composable useToast con gestión de stack reactivo",
            "description": "Implementar el composable useToast.js que gestiona el estado global de las notificaciones toast con un array reactivo y funciones para mostrar, ocultar y limpiar toasts",
            "dependencies": [],
            "details": "Crear src/composables/useToast.js con ref reactivo toasts (array). Implementar función show({type, message, duration=3000}) que genera ID único (timestamp o nanoid), agrega toast al array, y programa auto-dismiss con setTimeout. Función remove(id) para cerrar manualmente. Función clear() para limpiar todos. Tipos: 'success', 'error', 'warning', 'info' (mismo esquema que AppAlert). Exportar { toasts, show, remove, clear } para uso en componentes. Gestionar límite máximo de toasts simultáneos (ej: 5) con shift() del array si se excede.",
            "status": "done",
            "testStrategy": "Verificar que show() agrega toast al array, que auto-dismiss elimina después de duration, que remove() elimina por ID, que el límite máximo funciona, y que múltiples llamadas simultáneas gestionan el stack correctamente",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:33:20.785Z"
          },
          {
            "id": 2,
            "title": "Crear componente AppToast.vue con variantes y animaciones",
            "description": "Implementar el componente visual AppToast.vue con estilos por tipo, ícono, botón de cierre y animaciones de entrada/salida usando Transition",
            "dependencies": [
              1
            ],
            "details": "Crear src/components/common/AppToast.vue con props: type, message, dismissible (default true). Reutilizar esquema de colores e íconos de AppAlert (tarea 13): CheckCircle, XCircle, ExclamationTriangle, InformationCircle de Heroicons. Estructura: contenedor flex con ícono izquierdo, mensaje centro, botón X derecha si dismissible. Estilos: rounded-lg shadow-lg border-l-4 p-4 con colores por tipo. Usar Transition con name='toast' para slide-in desde derecha (transform translateX) y fade. Emitir @close al hacer click en X. Clase fixed con z-index alto para overlay.",
            "status": "done",
            "testStrategy": "Verificar que cada tipo renderiza con color/ícono correcto, que botón X cierra el toast, que animación de entrada/salida es fluida, y que los estilos son consistentes con AppAlert",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:33:20.792Z"
          },
          {
            "id": 3,
            "title": "Implementar contenedor de toasts con Teleport y TransitionGroup",
            "description": "Crear componente ToastContainer que renderiza el stack de toasts usando Teleport al body y TransitionGroup para animar múltiples elementos simultáneamente",
            "dependencies": [
              1,
              2
            ],
            "details": "Crear src/components/common/ToastContainer.vue que consume useToast composable para acceder a toasts array. Usar <Teleport to='body'> para renderizar fuera del DOM del componente padre. Contenedor fixed top-4 right-4 con z-50, flex flex-col gap-3 para stack vertical. Envolver lista de AppToast con <TransitionGroup name='toast-list' tag='div'> para animar entrada/salida de múltiples toasts. CSS para toast-list: slide + fade desde derecha. Pasar props a AppToast: key=toast.id, type, message, @close=remove(id). Agregar ToastContainer al App.vue raíz una sola vez. Max-width de 400px para toasts.",
            "status": "done",
            "testStrategy": "Verificar que toasts se renderizan en esquina superior derecha, que múltiples toasts se stackean correctamente, que TransitionGroup anima entrada/salida sin errores, que Teleport renderiza en body, y que el contenedor no interfiere con otros elementos de la UI",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:33:20.796Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear componente apptoast para notificaciones.",
        "updatedAt": "2025-12-12T02:33:20.796Z"
      },
      {
        "id": "17",
        "title": "Crear layout principal AppHeader",
        "description": "Implementar header de la aplicación con logo, navegación y menú de usuario",
        "details": "Crear src/components/layout/AppHeader.vue con: logo/título 'Sistema de Comicios Argentina 2025', navegación principal con RouterLink a las 5 páginas, menú de usuario (dropdown con Menu de HeadlessUI) mostrando nombre de usuario y opción de configuración. Header sticky top-0 con bg-primary text-white shadow-md. Navigation links con hover:bg-primary-dark, active con underline o bg diferente. Responsive: en mobile usar Disclosure de HeadlessUI para menú hamburguesa. Iconos: Bars3 (menu), Cog6Tooth (config).",
        "testStrategy": "Verificar que la navegación funciona con router, que el header es sticky, que el menú de usuario abre/cierra, que es responsive en mobile, y que los RouterLink activos se destacan",
        "priority": "medium",
        "dependencies": [
          "2",
          "7",
          "9"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base del componente AppHeader.vue",
            "description": "Implementar el componente base AppHeader con estructura HTML/template, estilos Tailwind y configuración sticky",
            "dependencies": [],
            "details": "Crear archivo src/components/layout/AppHeader.vue con estructura base: header sticky top-0 con clases bg-primary text-white shadow-md z-50. Incluir contenedor principal con max-width y padding responsive. Estructura dividida en tres secciones: logo/título a la izquierda, navegación al centro (oculta en mobile), y menú de usuario a la derecha. Aplicar estilos base de Tailwind para layout flex/grid responsive. Preparar slots o áreas para los elementos que se agregarán en siguientes subtareas.",
            "status": "pending",
            "testStrategy": "Verificar que el header se renderiza correctamente, que permanece sticky al hacer scroll, que los estilos bg-primary y text-white se aplican, y que la estructura responsive se adapta a mobile/desktop",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar navegación principal con RouterLink y estado activo",
            "description": "Añadir navegación con enlaces a las 5 páginas usando RouterLink, con estilos hover y active",
            "dependencies": [
              1
            ],
            "details": "Dentro de AppHeader, crear sección de navegación con RouterLink a: Dashboard ('/'), Cargar Telegrama ('/cargar-telegrama'), Resultados Provincial ('/resultados/provincial'), Resultados Nacional ('/resultados/nacional'), Configuración ('/configuracion'). Aplicar clases hover:bg-primary-dark a cada link. Usar clase 'router-link-active' o v-slot para destacar ruta activa con underline decoration-2 o bg-primary-dark. En desktop mostrar como flex horizontal, en mobile ocultar (md:flex hidden). Asegurar accesibilidad con aria-current en link activo.",
            "status": "pending",
            "testStrategy": "Verificar que todos los RouterLink navegan correctamente, que el link activo se destaca visualmente con underline o background diferente, que hover aplica bg-primary-dark, y que en mobile la navegación está oculta",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar menú de usuario con Menu de HeadlessUI y menú hamburguesa responsive",
            "description": "Añadir dropdown de usuario con HeadlessUI Menu y menú hamburguesa mobile con Disclosure",
            "dependencies": [
              2
            ],
            "details": "Importar Menu, MenuButton, MenuItems, MenuItem de @headlessui/vue. Crear dropdown de usuario: MenuButton con nombre de usuario (ej: 'Usuario Admin') y icono ChevronDown, MenuItems con opción 'Configuración' (Cog6Tooth icon) que navega a /configuracion. Aplicar Transition para animación fade/scale. Para mobile: importar Disclosure, DisclosureButton, DisclosurePanel. DisclosureButton con icono Bars3Icon (menú hamburguesa), visible solo en mobile (md:hidden). DisclosurePanel contiene los mismos RouterLink de navegación en vertical. Asegurar que ambos menús cierren al hacer clic fuera o al navegar.",
            "status": "pending",
            "testStrategy": "Verificar que el menú de usuario abre/cierra correctamente con animación, que la opción Configuración navega a /configuracion, que en mobile el botón hamburguesa (Bars3Icon) es visible, que el Disclosure abre/cierra el menú de navegación mobile, y que ambos menús se cierran automáticamente al interactuar",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear layout principal appheader.",
        "updatedAt": "2025-12-12T02:47:02.136Z"
      },
      {
        "id": "18",
        "title": "Crear layout AppFooter",
        "description": "Implementar footer con información del sistema y versión",
        "details": "Crear src/components/layout/AppFooter.vue con bg-gray-50 border-t. Mostrar: '© 2025 Sistema de Comicios Argentina - ESET UNQ', versión de la app desde import.meta.env.VITE_APP_VERSION, enlaces a documentación (opcional). Footer simple, centrado, text-sm text-gray-600. No sticky, al final del contenido. Puede incluir créditos del equipo: Ignacio González, Candela Ybañez Barrios, Silvina Torales, Samuel Angarita.",
        "testStrategy": "Verificar que el footer se renderiza al final de cada página, que la versión se lee correctamente de .env, y que los estilos son consistentes con el diseño",
        "priority": "low",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base del componente AppFooter.vue",
            "description": "Implementar el componente Vue base con su estructura HTML, estilos Tailwind y texto de copyright",
            "dependencies": [],
            "details": "Crear el archivo src/components/layout/AppFooter.vue con la estructura de componente Vue. Aplicar clases Tailwind: bg-gray-50 border-t para el contenedor principal. Agregar texto centrado con '© 2025 Sistema de Comicios Argentina - ESET UNQ' usando text-sm text-gray-600. Estructura del footer debe ser simple y no sticky, posicionado al final del contenido de cada página.",
            "status": "pending",
            "testStrategy": "Verificar que el componente se renderiza correctamente, que los estilos Tailwind se aplican (fondo gris claro, borde superior), que el texto está centrado y con el tamaño/color correcto",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Integrar variable de versión desde variables de entorno",
            "description": "Añadir la versión de la aplicación al footer leyendo desde import.meta.env.VITE_APP_VERSION",
            "dependencies": [
              1
            ],
            "details": "En AppFooter.vue, importar y mostrar la versión de la aplicación usando import.meta.env.VITE_APP_VERSION. Formato sugerido: 'v1.0.0' o similar. Asegurar que la variable VITE_APP_VERSION esté definida en el archivo .env del proyecto. Mostrar la versión junto al copyright de forma elegante (por ejemplo: 'Sistema de Comicios Argentina - ESET UNQ | v1.0.0').",
            "status": "pending",
            "testStrategy": "Verificar que la versión se lee correctamente del archivo .env, que se muestra en el footer, y que si no existe la variable de entorno no rompe el componente (mostrar fallback o no mostrar nada)",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Añadir créditos del equipo y enlaces opcionales",
            "description": "Agregar créditos del equipo de desarrollo y enlaces opcionales a documentación",
            "dependencies": [
              2
            ],
            "details": "Incluir créditos del equipo en el footer: Ignacio González, Candela Ybañez Barrios, Silvina Torales, Samuel Angarita. Puede ser en una línea separada con text-xs o similar. Opcionalmente agregar enlaces a documentación (si existe) usando RouterLink o <a> con estilos hover (text-primary hover:underline). Mantener el diseño limpio y no sobrecargar el footer. Todo con las mismas clases de texto (text-gray-600, text-sm o text-xs para créditos).",
            "status": "pending",
            "testStrategy": "Verificar que los créditos se muestran correctamente, que los enlaces (si existen) funcionan y tienen hover styles apropiados, y que el footer mantiene consistencia visual con el resto del diseño",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear layout appfooter.",
        "updatedAt": "2025-12-12T02:58:32.549Z"
      },
      {
        "id": "19",
        "title": "Crear componente StatsCard para dashboard",
        "description": "Implementar tarjeta de estadística con ícono, valor y etiqueta para el dashboard",
        "details": "Crear src/components/layout/StatsCard.vue basado en AppCard. Props: icon (component de Heroicons), label, value, subvalue (opcional), variant (color). Diseño: ícono grande a la izquierda con bg circular del color variant, valor grande a la derecha (text-3xl font-bold), label debajo (text-sm text-gray-600). Usar grid para layout. Variantes: primary, success, warning. Hover con scale-105 transform. Reutilizable para 'Mesas Cargadas', 'Telegramas Pendientes', 'Participación'.",
        "testStrategy": "Verificar que el ícono se renderiza correctamente, que el valor y label se muestran, que las variantes aplican colores correctos, y que el hover scale funciona",
        "priority": "medium",
        "dependencies": [
          "15"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base del componente StatsCard.vue",
            "description": "Crear el archivo del componente con la estructura base, props, y layout principal usando grid",
            "dependencies": [],
            "details": "Crear src/components/layout/StatsCard.vue extendiendo o importando AppCard. Definir props con TypeScript: icon (Component), label (string), value (string|number), subvalue (string|number, opcional), variant ('primary'|'success'|'warning'). Implementar layout con grid de 2 columnas: izquierda para ícono circular, derecha para valor y label apilados. Usar <script setup> syntax. Importar computed y defineProps. Estructura HTML: contenedor AppCard, div grid con gap-4, sección ícono y sección texto.",
            "status": "done",
            "testStrategy": "Verificar que el componente se renderiza sin errores, que acepta todas las props correctamente, y que la estructura grid se visualiza con dos columnas",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:18:51.436Z"
          },
          {
            "id": 2,
            "title": "Implementar sistema de variantes de color y estilos del ícono",
            "description": "Configurar las clases dinámicas para las variantes primary, success, warning y estilizar el ícono circular",
            "dependencies": [
              1
            ],
            "details": "Crear computed 'variantClasses' que retorna clases de Tailwind según variant: primary (bg-blue-100 text-blue-600), success (bg-green-100 text-green-600), warning (bg-yellow-100 text-yellow-600). Aplicar al contenedor circular del ícono: w-16 h-16 rounded-full flex items-center justify-center. Ícono con tamaño w-8 h-8. Aplicar clases dinámicas con :class binding. Asegurar que el componente de Heroicons se renderiza con la prop :is o component dinámico.",
            "status": "done",
            "testStrategy": "Verificar que cada variante (primary, success, warning) aplica los colores de fondo y texto correctos al círculo del ícono, y que los íconos de Heroicons se renderizan correctamente",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:18:51.442Z"
          },
          {
            "id": 3,
            "title": "Estilizar valores, labels y añadir efectos hover",
            "description": "Implementar la tipografía para valor y label, manejar subvalue opcional, y agregar animación hover",
            "dependencies": [
              2
            ],
            "details": "Estilizar sección derecha con flex flex-col justify-center. Valor principal: text-3xl font-bold text-gray-900. Label debajo: text-sm text-gray-600. Si subvalue existe, mostrarlo como text-xs text-gray-500 mt-1. Añadir clases de transición al contenedor principal: transition-transform duration-200 ease-in-out hover:scale-105. Asegurar cursor-pointer si es clickeable (opcional emit click). Formatear números grandes con separadores de miles usando toLocaleString() si value es número.",
            "status": "done",
            "testStrategy": "Verificar que el valor se muestra en text-3xl bold, que el label aparece debajo en text-sm, que subvalue se renderiza solo cuando está presente, y que el efecto hover scale-105 funciona suavemente",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:18:51.446Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear componente statscard para dashboard.",
        "updatedAt": "2025-12-12T02:18:51.446Z"
      },
      {
        "id": "20",
        "title": "Crear servicios de API: provinciaService y listaService",
        "description": "Implementar servicios para gestión de provincias y listas consumiendo endpoints del backend",
        "details": "Crear src/services/provinciaService.js con métodos: getAll(), getById(id), create(data), update(id, data), delete(id), getListas(id), getMesas(id). Cada método retorna la promesa de axios. Crear src/services/listaService.js con: getAll(), getById(id), getByProvincia(provinciaId), getCandidatos(listaId). Usar instancia api configurada. Endpoints según PRD sección 7.3: GET /provincias, GET /provincias/{id}/listas, etc. Manejar parámetros query con {params}. Retornar data.data del response para acceder directamente a payload.",
        "testStrategy": "Crear tests unitarios mockeando axios, verificar que los métodos llaman a los endpoints correctos con parámetros adecuados, y que retornan la estructura esperada",
        "priority": "high",
        "dependencies": [
          "5"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear provinciaService.js con métodos CRUD básicos",
            "description": "Implementar el servicio provinciaService.js con los métodos CRUD estándar para gestión de provincias",
            "dependencies": [],
            "details": "Crear archivo src/services/provinciaService.js. Importar la instancia api desde api.js configurado. Implementar métodos: getAll() que retorna api.get('/provincias').then(res => res.data.data), getById(id) que retorna api.get(`/provincias/${id}`).then(res => res.data.data), create(data) que retorna api.post('/provincias', data).then(res => res.data.data), update(id, data) que retorna api.put(`/provincias/${id}`, data).then(res => res.data.data), delete(id) que retorna api.delete(`/provincias/${id}`).then(res => res.data.data). Cada método debe retornar directamente data.data para simplificar el acceso al payload.",
            "status": "done",
            "testStrategy": "Crear tests unitarios mockeando axios para verificar que cada método llama al endpoint correcto con los parámetros adecuados y retorna la estructura data.data esperada",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T00:12:40.350Z"
          },
          {
            "id": 2,
            "title": "Implementar métodos relacionales en provinciaService",
            "description": "Agregar métodos getListas y getMesas al provinciaService para obtener recursos relacionados",
            "dependencies": [
              1
            ],
            "details": "En src/services/provinciaService.js, agregar método getListas(id) que retorna api.get(`/provincias/${id}/listas`).then(res => res.data.data) para obtener todas las listas de una provincia específica. Agregar método getMesas(id) que retorna api.get(`/provincias/${id}/mesas`).then(res => res.data.data) para obtener todas las mesas de una provincia. Estos métodos deben seguir el mismo patrón de extracción data.data que los métodos CRUD básicos. Verificar que los endpoints coinciden con la especificación PRD sección 7.3.",
            "status": "done",
            "testStrategy": "Verificar con tests unitarios que getListas y getMesas llaman a los endpoints correctos con el ID de provincia y retornan la estructura data.data esperada",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T00:12:40.429Z"
          },
          {
            "id": 3,
            "title": "Crear listaService.js con métodos de consulta básicos",
            "description": "Implementar el servicio listaService.js con métodos getAll y getById para gestión de listas",
            "dependencies": [],
            "details": "Crear archivo src/services/listaService.js. Importar la instancia api desde api.js. Implementar método getAll() que retorna api.get('/listas').then(res => res.data.data) para obtener todas las listas. Implementar método getById(id) que retorna api.get(`/listas/${id}`).then(res => res.data.data) para obtener una lista específica por ID. Seguir el mismo patrón de extracción data.data utilizado en provinciaService para consistencia en toda la aplicación.",
            "status": "done",
            "testStrategy": "Crear tests unitarios mockeando axios para verificar que getAll y getById llaman a los endpoints correctos y retornan data.data",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T00:12:40.516Z"
          },
          {
            "id": 4,
            "title": "Implementar métodos getByProvincia y getCandidatos en listaService",
            "description": "Agregar métodos para consultar listas por provincia y candidatos de una lista específica",
            "dependencies": [
              3
            ],
            "details": "En src/services/listaService.js, implementar método getByProvincia(provinciaId) que retorna api.get('/listas', {params: {provincia_id: provinciaId}}).then(res => res.data.data) para filtrar listas por provincia usando parámetros query. Implementar método getCandidatos(listaId) que retorna api.get(`/listas/${listaId}/candidatos`).then(res => res.data.data) para obtener los candidatos de una lista específica. Asegurar que el manejo de parámetros query se realiza correctamente usando la opción {params} de Axios.",
            "status": "done",
            "testStrategy": "Verificar que getByProvincia envía correctamente los parámetros query con {params}, que getCandidatos llama al endpoint correcto, y que ambos retornan data.data",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T00:12:40.590Z"
          },
          {
            "id": 5,
            "title": "Configurar manejo de parámetros query y extracción data.data",
            "description": "Estandarizar el manejo de parámetros query en todos los métodos y validar extracción consistente de data.data",
            "dependencies": [
              2,
              4
            ],
            "details": "Revisar todos los métodos en provinciaService.js y listaService.js para asegurar que utilizan correctamente {params} de Axios para parámetros query cuando sea necesario. Verificar que todos los métodos extraen data.data del response usando .then(res => res.data.data) para proporcionar acceso directo al payload sin envoltorios adicionales. Documentar en comentarios JSDoc el formato de retorno de cada método. Considerar agregar manejo de errores básico con .catch() si es necesario, aunque el manejo principal de errores debería estar en componentes/stores.",
            "status": "done",
            "testStrategy": "Realizar pruebas de integración verificando que todos los métodos retornan el payload directamente sin envoltorios, y que los parámetros query se envían correctamente",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T00:12:40.667Z"
          },
          {
            "id": 6,
            "title": "Verificar endpoints contra PRD sección 7.3",
            "description": "Validar que todos los endpoints implementados coinciden exactamente con la especificación del PRD",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Revisar el documento PRD sección 7.3 con la especificación de endpoints del backend. Crear una lista de verificación (checklist) comparando cada método implementado en provinciaService.js y listaService.js contra los endpoints documentados: GET /provincias, GET /provincias/{id}, POST /provincias, PUT /provincias/{id}, DELETE /provincias/{id}, GET /provincias/{id}/listas, GET /provincias/{id}/mesas, GET /listas, GET /listas/{id}, GET /listas (con params provincia_id), GET /listas/{id}/candidatos. Corregir cualquier discrepancia encontrada. Documentar los endpoints utilizados en comentarios al inicio de cada archivo de servicio.",
            "status": "done",
            "testStrategy": "Crear una matriz de trazabilidad entre métodos implementados y endpoints del PRD, verificar que no hay endpoints faltantes ni incorrectos",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T00:12:40.760Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Expandir en: (1) creación de provinciaService.js con métodos CRUD básicos (getAll, getById, create, update, delete), (2) implementación de métodos relacionales (getListas, getMesas), (3) creación de listaService.js con métodos de consulta, (4) implementación de getByProvincia y getCandidatos, (5) configuración de parámetros query y extracción de data.data, (6) verificación de endpoints según PRD sección 7.3.",
        "updatedAt": "2025-12-12T00:12:40.760Z"
      },
      {
        "id": "21",
        "title": "Crear servicios de API: mesaService y telegramaService",
        "description": "Implementar servicios para gestión de mesas y telegramas",
        "details": "Crear src/services/mesaService.js con: getAll(params), getById(id), getByProvincia(provinciaId), create(data), update(id, data). Crear src/services/telegramaService.js con: getAll(params), getById(id), getByMesa(mesaId), create(data), update(id, data), delete(id). Endpoints según PRD: GET /mesas, POST /telegramas, etc. Implementar serialización correcta de datos para POST (estructura según ejemplo PRD sección 15.2: {mesa_id, usuario, votos: [{lista_id, votos_diputados, votos_senadores}], blancos, nulos, recurridos}).",
        "testStrategy": "Verificar que telegramaService.create() envía payload correcto, que getByMesa filtra por mesa_id, y que los errores 422 se manejan correctamente retornando objeto de validación",
        "priority": "high",
        "dependencies": [
          "5"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear mesaService.js con métodos CRUD básicos",
            "description": "Implementar servicio para gestión de mesas con operaciones CRUD y métodos de filtrado",
            "dependencies": [],
            "details": "Crear archivo src/services/mesaService.js. Implementar métodos: getAll(params) para GET /mesas con parámetros query, getById(id) para GET /mesas/{id}, getByProvincia(provinciaId) para filtrar mesas por provincia, create(data) para POST /mesas, update(id, data) para PUT /mesas/{id}. Usar instancia api de axios configurada. Retornar data.data del response para consistencia. Incluir manejo de errores básico con try-catch.",
            "status": "done",
            "testStrategy": "Verificar que getAll retorna listado de mesas, getByProvincia filtra correctamente por provincia_id, y que create/update envían payload adecuado",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T00:35:53.730Z"
          },
          {
            "id": 2,
            "title": "Crear telegramaService.js con operaciones básicas",
            "description": "Implementar servicio base para telegramas con métodos CRUD estándar",
            "dependencies": [
              1
            ],
            "details": "Crear archivo src/services/telegramaService.js. Implementar métodos básicos: getAll(params) para GET /telegramas, getById(id) para GET /telegramas/{id}, getByMesa(mesaId) para GET /telegramas?mesa_id={mesaId}, update(id, data) para PUT /telegramas/{id}, delete(id) para DELETE /telegramas/{id}. Dejar create(data) como stub para implementar en subtarea posterior con serialización compleja. Usar instancia api de axios.",
            "status": "done",
            "testStrategy": "Verificar que getByMesa filtra correctamente por mesa_id, que update modifica telegrama existente, y que delete retorna confirmación",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T00:35:53.930Z"
          },
          {
            "id": 3,
            "title": "Implementar serialización compleja para POST de telegramas",
            "description": "Crear método create() con estructura de payload según PRD sección 15.2",
            "dependencies": [
              2
            ],
            "details": "Implementar telegramaService.create(data) con serialización correcta del payload. Estructura esperada: {mesa_id: number, usuario: string, votos: [{lista_id: number, votos_diputados: number, votos_senadores: number}], blancos: {diputados: number, senadores: number}, nulos: {diputados: number, senadores: number}, recurridos: {diputados: number, senadores: number}}. Validar que el array votos contenga al menos un elemento. Asegurar que todos los campos numéricos sean integers. Endpoint: POST /telegramas con Content-Type application/json.",
            "status": "done",
            "testStrategy": "Verificar que create() envía payload con estructura correcta incluyendo array de votos anidado, que los tipos de datos son correctos (integers), y que el backend acepta el request sin errores de validación",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T00:35:54.152Z"
          },
          {
            "id": 4,
            "title": "Implementar manejo de errores 422 de validación Laravel",
            "description": "Añadir interceptor y manejo específico para errores de validación del backend",
            "dependencies": [
              3
            ],
            "details": "En mesaService.js y telegramaService.js, implementar manejo específico de errores HTTP 422. Laravel retorna estructura: {message: string, errors: {campo: [array de mensajes]}}. Crear función helper parseValidationErrors(error) que extraiga y formatee los mensajes de validación. En bloques catch, detectar error.response.status === 422 y retornar objeto estructurado con errores por campo. Esto permitirá que los componentes muestren mensajes de validación específicos en los formularios.",
            "status": "done",
            "testStrategy": "Simular error 422 del backend y verificar que el servicio retorna objeto de errores correctamente parseado con estructura {campo: [mensajes]}, que se preserva el mensaje principal",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T00:35:54.356Z"
          },
          {
            "id": 5,
            "title": "Implementar filtrado avanzado en getByMesa",
            "description": "Añadir parámetros adicionales de filtrado para consulta de telegramas por mesa",
            "dependencies": [
              2
            ],
            "details": "Mejorar método getByMesa(mesaId, params = {}) en telegramaService.js para soportar filtros adicionales: cargo ('DIPUTADOS'|'SENADORES'), fecha_desde, fecha_hasta, usuario. Construir query string combinando mesa_id con params opcionales. Ejemplo: GET /telegramas?mesa_id=123&cargo=DIPUTADOS&usuario=operador1. Retornar array de telegramas filtrados. Documentar parámetros disponibles en JSDoc del método.",
            "status": "done",
            "testStrategy": "Verificar que getByMesa sin params retorna todos los telegramas de la mesa, que con cargo='DIPUTADOS' filtra correctamente, y que combinación de múltiples filtros funciona",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T00:35:54.567Z"
          },
          {
            "id": 6,
            "title": "Testing integral de payload complejo de telegramas",
            "description": "Crear suite de tests para validar serialización y casos edge del payload de telegramas",
            "dependencies": [
              3,
              4
            ],
            "details": "Crear archivo tests/services/telegramaService.test.js. Test cases: 1) Payload mínimo válido con un voto, 2) Payload completo con múltiples votos y todos los campos, 3) Validación de campos requeridos (mesa_id, usuario, votos), 4) Manejo de error 422 con campos faltantes, 5) Validación de tipos de datos (integers vs strings), 6) Array de votos vacío debe fallar, 7) Valores negativos en votos debe manejarse según reglas de negocio. Mockear axios para simular respuestas del backend. Verificar que la estructura JSON serializada es exactamente como espera Laravel.",
            "status": "done",
            "testStrategy": "Ejecutar suite completa y verificar 100% cobertura de casos edge, que payload válido pasa sin errores, que payloads inválidos generan errores apropiados, y que estructura JSON coincide con ejemplo PRD 15.2",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T00:35:54.792Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Dividir en: (1) creación de mesaService.js con métodos CRUD y filtros, (2) creación de telegramaService.js con operaciones básicas, (3) implementación de serialización compleja para POST de telegramas según estructura PRD sección 15.2, (4) implementación de getByMesa con filtrado, (5) manejo de errores 422 de validación Laravel, (6) testing de payload complejo (mesa_id, usuario, votos array, blancos, nulos, recurridos).",
        "updatedAt": "2025-12-12T00:35:54.792Z"
      },
      {
        "id": "22",
        "title": "Crear servicios de API: resultadoService e importExportService",
        "description": "Implementar servicios para consulta de resultados e importación/exportación CSV",
        "details": "Crear src/services/resultadoService.js con: getProvincial(provinciaId, params), getNacional(params), getByCandidato(candidatoId), getByLista(listaId). params incluye {cargo: 'DIPUTADOS'|'SENADORES'}. Crear src/services/importExportService.js con: importProvincias(file), importListas(file), importMesas(file), importTelegramas(file), exportProvincial(provinciaId), exportNacional(). Métodos de import usan FormData con Content-Type multipart/form-data. Métodos de export usan responseType: 'blob' y retornan Blob para descarga. Crear helper downloadBlob(blob, filename) en utils.",
        "testStrategy": "Verificar que getProvincial retorna estructura según PRD sección 15.2, que importTelegramas envía FormData correctamente, y que exportNacional retorna blob descargable",
        "priority": "high",
        "dependencies": [
          "5"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear resultadoService.js con métodos de consulta provincial y nacional",
            "description": "Implementar src/services/resultadoService.js con métodos getProvincial(provinciaId, params) y getNacional(params) para consultar resultados electorales",
            "dependencies": [],
            "details": "Crear archivo src/services/resultadoService.js. Importar instancia api de axiosConfig.js. Implementar método getProvincial(provinciaId, params) que llama GET /resultados/provincial/{provinciaId} con params query. Implementar método getNacional(params) que llama GET /resultados/nacional con params query. Ambos métodos retornan promesa de axios con data.data. Estructura de params: {cargo: 'DIPUTADOS'|'SENADORES'}. Validar que provinciaId es requerido en getProvincial. Usar desestructuración para extraer data del response.",
            "status": "done",
            "testStrategy": "Verificar con mock de axios que getProvincial(1, {cargo: 'DIPUTADOS'}) llama endpoint correcto, que getNacional retorna estructura según PRD sección 15.2, y que params se pasan correctamente como query string",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T00:44:33.600Z"
          },
          {
            "id": 2,
            "title": "Implementar métodos getByCandidato y getByLista en resultadoService",
            "description": "Agregar métodos de consulta por candidato y por lista al servicio de resultados",
            "dependencies": [
              1
            ],
            "details": "En src/services/resultadoService.js, implementar método getByCandidato(candidatoId) que llama GET /resultados/candidato/{candidatoId}. Implementar método getByLista(listaId) que llama GET /resultados/lista/{listaId}. Ambos métodos aceptan params opcional para filtrado por cargo. Validar que IDs son numéricos y requeridos. Retornar data.data del response. Mantener consistencia con métodos anteriores en manejo de errores y estructura de retorno.",
            "status": "done",
            "testStrategy": "Verificar que getByCandidato(5) llama endpoint /resultados/candidato/5, que getByLista acepta params opcionales, y que ambos métodos manejan errores 404 correctamente",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T00:44:33.607Z"
          },
          {
            "id": 3,
            "title": "Crear importExportService.js con métodos de importación usando FormData",
            "description": "Implementar src/services/importExportService.js con métodos de importación de archivos CSV usando multipart/form-data",
            "dependencies": [],
            "details": "Crear archivo src/services/importExportService.js. Importar instancia api de axiosConfig.js. Implementar métodos: importProvincias(file), importListas(file), importMesas(file), importTelegramas(file). Cada método crea FormData, agrega el archivo con append('file', file), y hace POST al endpoint correspondiente (/import/provincias, /import/listas, etc.) con headers {'Content-Type': 'multipart/form-data'}. Retornar data.data del response que incluye resumen de importación (registros procesados, errores).",
            "status": "done",
            "testStrategy": "Verificar que importTelegramas crea FormData correctamente, que header Content-Type se establece como multipart/form-data, y que el archivo se envía con key 'file'",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T00:44:33.620Z"
          },
          {
            "id": 4,
            "title": "Implementar métodos de exportación con responseType blob en importExportService",
            "description": "Agregar métodos de exportación que retornan archivos CSV como Blob para descarga",
            "dependencies": [
              3
            ],
            "details": "En src/services/importExportService.js, implementar métodos exportProvincial(provinciaId) y exportNacional(). exportProvincial llama GET /export/provincial/{provinciaId} con {responseType: 'blob'}. exportNacional llama GET /export/nacional con {responseType: 'blob'}. Ambos métodos retornan directamente el response.data que es un Blob. Agregar parámetros opcionales para filtros (cargo, fecha). Documentar que el retorno es Blob listo para usar con downloadBlob helper.",
            "status": "done",
            "testStrategy": "Verificar que exportNacional retorna instancia de Blob, que responseType: 'blob' se configura en axios, y que el Blob tiene content-type 'text/csv'",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T00:44:33.630Z"
          },
          {
            "id": 5,
            "title": "Crear helper downloadBlob en utils para descarga de archivos",
            "description": "Implementar función utilitaria para descargar archivos Blob en el navegador",
            "dependencies": [],
            "details": "Crear o actualizar src/utils/index.js. Implementar función downloadBlob(blob, filename). La función crea URL temporal con URL.createObjectURL(blob), crea elemento <a> con href=url y download=filename, agrega al DOM, dispara click(), remueve elemento del DOM, y revoca URL con URL.revokeObjectURL(url) para liberar memoria. Validar que blob es instancia de Blob y filename es string. Exportar función. Agregar comentario JSDoc explicando parámetros y uso.",
            "status": "done",
            "testStrategy": "Crear test que verifica creación de elemento <a>, que se dispara click, que URL se revoca, y que funciona con diferentes tipos de Blob (CSV, JSON)",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T00:44:33.641Z"
          },
          {
            "id": 6,
            "title": "Integrar downloadBlob con métodos de exportación",
            "description": "Conectar helper downloadBlob con servicios de exportación para flujo completo de descarga",
            "dependencies": [
              4,
              5
            ],
            "details": "Actualizar documentación en importExportService.js mostrando ejemplo de uso: exportNacional().then(blob => downloadBlob(blob, 'resultados-nacional.csv')). Opcionalmente crear wrappers convenientes: exportProvincialAndDownload(provinciaId, filename) que internamente llama exportProvincial y downloadBlob. Agregar manejo de errores para casos donde el backend retorna error en lugar de blob. Verificar que filename se genera automáticamente si no se provee (formato: resultados-provincial-{id}-{timestamp}.csv).",
            "status": "done",
            "testStrategy": "Verificar que llamar exportNacional().then(blob => downloadBlob(blob, 'test.csv')) descarga archivo correctamente en navegador, que filename se respeta, y que errores del backend se manejan sin intentar descargar",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T00:44:33.655Z"
          },
          {
            "id": 7,
            "title": "Testing de integración de descarga de archivos CSV",
            "description": "Crear tests de integración para verificar flujo completo de exportación y descarga",
            "dependencies": [
              6
            ],
            "details": "Crear tests que mocken axios para retornar Blob simulado. Verificar que exportProvincial(1) genera descarga con nombre correcto. Testear que importTelegramas(mockFile) envía FormData correctamente. Verificar que errores de validación (422) del backend se manejan retornando objeto con errores. Testear que downloadBlob limpia URLs correctamente sin memory leaks. Crear test de integración que simula seleccionar archivo, importar, exportar resultados, y descargar CSV. Documentar casos edge: archivos vacíos, archivos muy grandes, formatos incorrectos.",
            "status": "done",
            "testStrategy": "Test de integración completo: mock file upload → importTelegramas → verificar FormData → mock export response → exportNacional → verificar Blob → downloadBlob → verificar descarga y cleanup de URLs",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T00:45:18.730Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Expandir en: (1) creación de resultadoService.js con métodos de consulta provincial y nacional, (2) implementación de filtrado por cargo (DIPUTADOS/SENADORES), (3) creación de importExportService.js para operaciones de archivo, (4) implementación de métodos de import con FormData y multipart/form-data, (5) implementación de métodos export con responseType: 'blob', (6) creación de helper downloadBlob en utils, (7) testing de descarga de archivos CSV.",
        "updatedAt": "2025-12-12T00:45:18.730Z"
      },
      {
        "id": "23",
        "title": "Implementar Pinia store: provinciaStore",
        "description": "Crear store de Pinia para gestión de provincias con acciones asíncronas",
        "details": "Crear src/stores/provinciaStore.js con defineStore('provincia', () => {...}) usando Composition API style. State: provincias (array), provinciaActual (object|null), loading (boolean), error (object|null). Getters: provinciaById(id), provinciasOrdenadas. Actions: fetchProvincias() llamando provinciaService.getAll(), fetchProvincia(id), setProvinciaActual(provincia). Manejar loading y error states. Usar ref() para state, computed() para getters. Retornar objeto con state, getters, actions. Implementar error handling con try/catch.",
        "testStrategy": "Verificar que fetchProvincias() llena el array provincias, que loading cambia durante la petición, que provinciaById retorna la correcta, y que los errores se capturan en error state",
        "priority": "high",
        "dependencies": [
          "4",
          "20"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base del provinciaStore con state y configuración inicial",
            "description": "Implementar el archivo base del store de Pinia para provincias utilizando Composition API con defineStore",
            "dependencies": [],
            "details": "Crear archivo src/stores/provinciaStore.js. Importar { defineStore } de 'pinia', { ref, computed } de 'vue'. Definir export const useProvinciaStore = defineStore('provincia', () => {...}). Implementar state usando ref(): provincias = ref([]), provinciaActual = ref(null), loading = ref(false), error = ref(null). Inicializar la estructura básica del store siguiendo el patrón Composition API de Pinia. Asegurar que el store esté correctamente exportado y disponible para su uso en componentes.",
            "status": "done",
            "testStrategy": "Verificar que el store se puede importar correctamente con useProvinciaStore(), que todos los states están inicializados con los valores correctos (provincias como array vacío, provinciaActual como null, loading como false, error como null)",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T00:54:18.432Z"
          },
          {
            "id": 2,
            "title": "Implementar getters computed para provinciaById y provinciasOrdenadas",
            "description": "Crear getters computados que permitan buscar provincias por ID y obtener la lista ordenada alfabéticamente",
            "dependencies": [
              1
            ],
            "details": "Dentro del defineStore, crear computed getters. provinciaById = computed(() => (id) => provincias.value.find(p => p.id === id)). provinciasOrdenadas = computed(() => [...provincias.value].sort((a, b) => a.nombre.localeCompare(b.nombre))). Usar computed() de Vue para que sean reactivos. Asegurar que provinciaById retorna una función que acepta id como parámetro. Retornar ambos getters en el objeto final del store.",
            "status": "done",
            "testStrategy": "Verificar que provinciaById(id) retorna la provincia correcta cuando existe, retorna undefined cuando no existe, y que provinciasOrdenadas retorna el array ordenado alfabéticamente por nombre sin mutar el array original",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T00:54:18.519Z"
          },
          {
            "id": 3,
            "title": "Implementar actions asíncronas con manejo de estados de loading y error",
            "description": "Crear las acciones fetchProvincias, fetchProvincia y setProvinciaActual con control de estados asíncronos",
            "dependencies": [
              1,
              2
            ],
            "details": "Importar provinciaService desde '@/services/provinciaService.js'. Implementar fetchProvincias = async () => { try { loading.value = true; error.value = null; const data = await provinciaService.getAll(); provincias.value = data; } catch (err) { error.value = { message: err.message, code: err.code || 'UNKNOWN' }; throw err; } finally { loading.value = false; } }. Implementar fetchProvincia = async (id) => { try { loading.value = true; error.value = null; const data = await provinciaService.getById(id); provinciaActual.value = data; return data; } catch (err) { error.value = { message: err.message, code: err.code }; throw err; } finally { loading.value = false; } }. Implementar setProvinciaActual = (provincia) => { provinciaActual.value = provincia; }. Retornar objeto final: return { provincias, provinciaActual, loading, error, provinciaById, provinciasOrdenadas, fetchProvincias, fetchProvincia, setProvinciaActual }",
            "status": "done",
            "testStrategy": "Verificar que fetchProvincias() llena el array provincias con datos del servicio, que loading cambia a true durante la petición y a false al finalizar, que error se setea correctamente en caso de fallo con message y code, que fetchProvincia(id) actualiza provinciaActual, y que setProvinciaActual actualiza el state sin llamadas asíncronas",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T00:54:18.586Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar pinia store: provinciastore.",
        "updatedAt": "2025-12-12T00:54:18.586Z"
      },
      {
        "id": "24",
        "title": "Implementar Pinia store: mesaStore",
        "description": "Crear store para gestión de mesas con filtrado por provincia",
        "details": "Crear src/stores/mesaStore.js. State: mesas (array), mesaSeleccionada (object|null), loading, error. Getters: mesasPorProvincia(provinciaId), mesaById(id). Actions: fetchMesas(params), fetchMesasPorProvincia(provinciaId), setMesaSeleccionada(mesa), buscarMesa(query) para búsqueda local. Implementar debounce en buscarMesa para optimizar búsqueda. Cachear mesas para evitar peticiones repetidas (usar Map con provinciaId como key).",
        "testStrategy": "Verificar que fetchMesasPorProvincia filtra correctamente, que setMesaSeleccionada actualiza el state, que buscarMesa retorna resultados filtrados, y que el cache funciona",
        "priority": "high",
        "dependencies": [
          "4",
          "21"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base del mesaStore con state, refs y tipos",
            "description": "Crear el archivo src/stores/mesaStore.js e implementar la estructura básica del store usando Composition API de Pinia con todos los estados reactivos necesarios",
            "dependencies": [],
            "details": "Crear src/stores/mesaStore.js usando defineStore('mesa', () => {...}). Definir state usando ref(): mesas (ref([])), mesaSeleccionada (ref(null)), loading (ref(false)), error (ref(null)), cache (ref(new Map())). Importar ref, computed desde Vue y defineStore desde Pinia. Establecer la estructura base del store siguiendo el patrón Composition API. Exportar default defineStore con nombre 'mesa'.",
            "status": "done",
            "testStrategy": "Verificar que el store se puede importar correctamente, que todos los refs se inicializan con valores por defecto adecuados, y que el cache se inicializa como Map vacío",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T00:58:57.109Z"
          },
          {
            "id": 2,
            "title": "Implementar getters mesasPorProvincia y mesaById con computed",
            "description": "Crear getters reactivos usando computed para filtrado por provincia y búsqueda por ID de mesa",
            "dependencies": [
              1
            ],
            "details": "Implementar getter mesasPorProvincia como función que retorna computed(() => (provinciaId) => mesas.value.filter(m => m.provinciaId === provinciaId)). Implementar mesaById como función que retorna computed(() => (id) => mesas.value.find(m => m.id === id)). Ambos getters deben ser eficientes y reactivos usando computed de Vue. Asegurar que los filtros manejan casos donde no hay resultados retornando array vacío o undefined según corresponda.",
            "status": "done",
            "testStrategy": "Verificar que mesasPorProvincia filtra correctamente mesas por provinciaId dado, que mesaById retorna la mesa correcta o undefined si no existe, y que ambos getters son reactivos ante cambios en mesas.value",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T00:58:57.180Z"
          },
          {
            "id": 3,
            "title": "Implementar actions con cache, debounce y manejo de errores",
            "description": "Crear todas las actions del store: fetchMesas, fetchMesasPorProvincia con cache, setMesaSeleccionada y buscarMesa con debounce",
            "dependencies": [
              1,
              2
            ],
            "details": "Implementar fetchMesas(params) llamando mesaService.getAll(params) con manejo de loading/error. Implementar fetchMesasPorProvincia(provinciaId) verificando cache.value.has(provinciaId) primero, si no existe llamar mesaService.getByProvincia(provinciaId) y guardar en cache.value.set(provinciaId, resultado). Implementar setMesaSeleccionada(mesa) que actualiza mesaSeleccionada.value. Implementar buscarMesa(query) con debounce de 300ms usando setTimeout, que filtra mesas.value localmente por query en campos relevantes (número, dirección). Limpiar timeout anterior en cada nueva búsqueda. Retornar objeto con todos los states, getters y actions al final del defineStore.",
            "status": "done",
            "testStrategy": "Verificar que fetchMesasPorProvincia no hace llamadas repetidas para misma provinciaId (cache funciona), que buscarMesa tiene debounce de 300ms, que setMesaSeleccionada actualiza correctamente el state, y que todos los errores se capturan en error.value",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T00:58:57.252Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar pinia store: mesastore.",
        "updatedAt": "2025-12-12T00:58:57.252Z"
      },
      {
        "id": "25",
        "title": "Implementar Pinia store: telegramaStore",
        "description": "Crear store para gestión de telegramas con validación y estado de guardado",
        "details": "Crear src/stores/telegramaStore.js según ejemplo PRD sección 8.1. State: telegramas, telegramaActual, mesaSeleccionada, loading, saving, error, validationErrors. Getters: telegramasPorMesa(mesaId), totalVotos (calculado). Actions: guardarTelegrama(data) retornando {success, data/error}, actualizarTelegrama(id, data), eliminarTelegrama(id), limpiarFormulario(). Implementar lógica de validación local antes de enviar (suma de votos <= electores). Manejar errores 422 mapeando a validationErrors para mostrar en formulario.",
        "testStrategy": "Verificar que guardarTelegrama retorna success: true si OK, que validationErrors se mapea de errores 422, que totalVotos calcula correctamente, y que limpiarFormulario resetea state",
        "priority": "high",
        "dependencies": [
          "4",
          "21"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar estructura base del telegramaStore",
            "description": "Crear el archivo telegramaStore.js con la estructura básica de Pinia usando Composition API y definir todos los estados reactivos necesarios",
            "dependencies": [],
            "details": "Crear src/stores/telegramaStore.js usando defineStore('telegrama', () => {...}). Definir state con ref(): telegramas (array vacío), telegramaActual (null), mesaSeleccionada (null), loading (false), saving (false), error (null), validationErrors (objeto vacío). Importar ref y computed de Vue. Preparar la estructura para exportar el store con todos los estados, getters y actions que se implementarán en las siguientes subtareas.",
            "status": "done",
            "testStrategy": "Verificar que el store se importa correctamente en otros componentes, que todos los estados reactivos se inicializan con los valores por defecto correctos, y que el store está registrado en Pinia",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T01:08:24.536Z"
          },
          {
            "id": 2,
            "title": "Implementar getters y lógica de cálculo de votos",
            "description": "Crear los getters computed para filtrado de telegramas por mesa y cálculo automático del total de votos",
            "dependencies": [
              1
            ],
            "details": "Implementar getters usando computed(): telegramasPorMesa(mesaId) que filtra array telegramas por mesaId, totalVotos que suma todos los votos de candidatos del telegramaActual. El getter totalVotos debe iterar sobre las propiedades de votos del telegrama actual y retornar la suma total. Asegurar que los getters son reactivos y se actualizan automáticamente cuando cambia el state.",
            "status": "done",
            "testStrategy": "Verificar que telegramasPorMesa retorna solo telegramas de la mesa especificada, que totalVotos calcula correctamente la suma de todos los votos incluyendo votos en blanco y nulos, y que los getters son reactivos",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T01:08:24.542Z"
          },
          {
            "id": 3,
            "title": "Implementar actions con validación y manejo de errores",
            "description": "Crear todas las actions para gestión de telegramas incluyendo validación local, llamadas al servicio API y manejo de errores de validación del backend",
            "dependencies": [
              2
            ],
            "details": "Implementar actions: guardarTelegrama(data) con validación local (totalVotos <= electores de mesa), llamada a telegramaService, retorno {success: true, data} o {success: false, error}. actualizarTelegrama(id, data) y eliminarTelegrama(id) con llamadas al servicio. limpiarFormulario() reseteando telegramaActual, mesaSeleccionada, validationErrors. Manejar estados loading/saving durante peticiones. Capturar errores 422 del backend y mapear response.data.errors a validationErrors para mostrar en formulario. Implementar try-catch en todas las actions asíncronas.",
            "status": "done",
            "testStrategy": "Verificar que guardarTelegrama retorna success: true cuando OK y success: false con errores de validación, que validationErrors se mapea correctamente de errores 422 del backend, que limpiarFormulario resetea todos los campos del state, y que los estados loading/saving se actualizan correctamente",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T01:08:24.548Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar pinia store: telegramastore.",
        "updatedAt": "2025-12-12T01:08:24.548Z"
      },
      {
        "id": "26",
        "title": "Implementar Pinia store: resultadoStore",
        "description": "Crear store para consulta de resultados provinciales y nacionales",
        "details": "Crear src/stores/resultadoStore.js según ejemplo PRD sección 8.1. State: resultadoProvincial, resultadoNacional, cargoSeleccionado ('DIPUTADOS'), loading, error. Getters: listasMasVotadas (ordenadas por votos desc), participacionPorcentaje ((votos_emitidos/electores)*100). Actions: fetchResultadoProvincial(provinciaId), fetchResultadoNacional(), setCargo(cargo), refresh() para recargar datos. Cachear resultados por 30 segundos para evitar peticiones excesivas. Implementar auto-refresh opcional cada X segundos para dashboard en vivo.",
        "testStrategy": "Verificar que fetchResultadoProvincial retorna estructura según PRD, que listasMasVotadas ordena correctamente, que participacionPorcentaje calcula bien, y que setCargo recarga datos con nuevo cargo",
        "priority": "high",
        "dependencies": [
          "4",
          "22"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base del resultadoStore con state y configuración inicial",
            "description": "Implementar el archivo src/stores/resultadoStore.js con la estructura base usando Composition API de Pinia, definir state reactivo (resultadoProvincial, resultadoNacional, cargoSeleccionado, loading, error) y configurar sistema de caché de 30 segundos",
            "dependencies": [],
            "details": "Crear src/stores/resultadoStore.js usando defineStore('resultado', () => {...}). Definir state con ref(): resultadoProvincial (object|null), resultadoNacional (object|null), cargoSeleccionado (string default 'DIPUTADOS'), loading (boolean), error (object|null). Implementar sistema de caché usando Map con timestamps para guardar resultados por 30 segundos: cacheProvincial = new Map(), cacheNacional = new Map(). Agregar helper function isCacheValid(timestamp) que retorne true si Date.now() - timestamp < 30000. Importar resultadoService desde services/resultadoService.js. Estructura completa lista para recibir getters y actions.",
            "status": "done",
            "testStrategy": "Verificar que el store se inicializa correctamente con valores default (cargoSeleccionado='DIPUTADOS', resultados=null), que los ref() son reactivos, y que la estructura de caché está disponible",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T01:06:02.705Z"
          },
          {
            "id": 2,
            "title": "Implementar getters para procesamiento de datos de resultados",
            "description": "Crear getters usando computed() para listasMasVotadas (ordenar listas por votos descendentes) y participacionPorcentaje (calcular porcentaje de participación según fórmula)",
            "dependencies": [
              1
            ],
            "details": "Implementar getters con computed(). 1) listasMasVotadas: computed(() => { if (!resultadoProvincial.value && !resultadoNacional.value) return []; const resultado = resultadoProvincial.value || resultadoNacional.value; return [...resultado.listas].sort((a, b) => b.votos - a.votos); }). 2) participacionPorcentaje: computed(() => { const resultado = resultadoProvincial.value || resultadoNacional.value; if (!resultado?.votos_emitidos || !resultado?.electores) return 0; return ((resultado.votos_emitidos / resultado.electores) * 100).toFixed(2); }). Ambos getters deben manejar casos null/undefined y priorizar resultadoProvincial si existe, sino usar resultadoNacional.",
            "status": "done",
            "testStrategy": "Verificar que listasMasVotadas ordena correctamente array de listas por votos descendentes, que participacionPorcentaje calcula (votos_emitidos/electores)*100 con 2 decimales, y que ambos manejan casos null sin errores",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T01:06:02.715Z"
          },
          {
            "id": 3,
            "title": "Implementar actions asíncronas con caché y auto-refresh opcional",
            "description": "Crear actions fetchResultadoProvincial, fetchResultadoNacional, setCargo, refresh con lógica de caché de 30 segundos y sistema de auto-refresh configurable para dashboard en vivo",
            "dependencies": [
              2
            ],
            "details": "Implementar actions: 1) fetchResultadoProvincial(provinciaId): verificar cache, si válido retornar cached, sino loading=true, llamar resultadoService.getResultadoProvincial(provinciaId, cargoSeleccionado.value), guardar en resultadoProvincial y cacheProvincial.set(provinciaId, {data, timestamp}), manejar error. 2) fetchResultadoNacional(): igual lógica con cacheNacional. 3) setCargo(cargo): actualizar cargoSeleccionado.value=cargo, limpiar caches, re-fetch datos actuales. 4) refresh(): limpiar caches y re-fetch datos. 5) Implementar auto-refresh opcional: autoRefreshInterval (ref null), startAutoRefresh(segundos), stopAutoRefresh() usando setInterval/clearInterval. Retornar objeto final con {resultadoProvincial, resultadoNacional, cargoSeleccionado, loading, error, listasMasVotadas, participacionPorcentaje, fetchResultadoProvincial, fetchResultadoNacional, setCargo, refresh, startAutoRefresh, stopAutoRefresh}.",
            "status": "done",
            "testStrategy": "Verificar que fetchResultadoProvincial usa caché válido y no hace petición duplicada dentro de 30s, que setCargo recarga datos con nuevo cargo, que refresh limpia caché y recarga, que startAutoRefresh/stopAutoRefresh funcionan correctamente sin memory leaks",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T01:06:02.720Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar pinia store: resultadostore.",
        "updatedAt": "2025-12-12T01:06:02.720Z"
      },
      {
        "id": "27",
        "title": "Crear utilidades de validación",
        "description": "Implementar funciones de validación reutilizables para formularios",
        "details": "Crear src/utils/validators.js con funciones: validateVotos(votos, electores) retornando {valid: boolean, error: string}, validateTelegrama(telegramaData) validando estructura completa, validateEmail(email), validateNumeroPositivo(numero), validateRequerido(valor). Usar regex para email. validateVotos verifica: suma <= electores, todos números >= 0, al menos 1 voto. validateTelegrama verifica: mesa_id existe, usuario no vacío, array votos válido. Retornar objetos con {valid, errors: {field: message}}. Usar en stores y componentes de formulario.",
        "testStrategy": "Crear tests unitarios para cada función, verificar que validateVotos detecta sumas excesivas, que validateEmail acepta/rechaza correctamente, y que retornan estructura esperada",
        "priority": "medium",
        "dependencies": [
          "8"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar funciones de validación básicas",
            "description": "Crear archivo validators.js con funciones básicas de validación: validateEmail, validateNumeroPositivo y validateRequerido",
            "dependencies": [],
            "details": "Crear src/utils/validators.js. Implementar validateEmail(email) usando regex /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/ retornando {valid: boolean, error: string}. Implementar validateNumeroPositivo(numero) verificando que sea número >= 0. Implementar validateRequerido(valor) verificando que no sea null/undefined/vacío. Cada función debe retornar objeto {valid: boolean, error: string} con mensajes en español. Usar expresiones regulares nativas de JavaScript.",
            "status": "done",
            "testStrategy": "Crear tests unitarios verificando que validateEmail acepta emails válidos y rechaza inválidos, que validateNumeroPositivo acepta solo números >= 0, y que validateRequerido detecta valores vacíos correctamente",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T01:44:37.363Z"
          },
          {
            "id": 2,
            "title": "Implementar validación de votos",
            "description": "Crear función validateVotos para validar array de votos contra cantidad de electores",
            "dependencies": [
              1
            ],
            "details": "En src/utils/validators.js, implementar validateVotos(votos, electores) que verifica: 1) todos los valores en array votos son números >= 0, 2) suma total de votos <= electores, 3) existe al menos 1 voto. Retornar {valid: boolean, error: string}. Mensajes de error específicos: 'Los votos deben ser números positivos', 'La suma de votos excede el total de electores', 'Debe haber al menos un voto'. Usar Array.every() y Array.reduce() para validaciones.",
            "status": "done",
            "testStrategy": "Verificar que detecta votos negativos, que rechaza sumas mayores a electores, que requiere al menos 1 voto, que acepta arrays válidos, y que retorna estructura {valid, error} esperada",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T01:44:37.438Z"
          },
          {
            "id": 3,
            "title": "Implementar validación de telegrama completo",
            "description": "Crear función validateTelegrama para validar estructura completa del telegrama con múltiples campos",
            "dependencies": [
              2
            ],
            "details": "En src/utils/validators.js, implementar validateTelegrama(telegramaData) validando: 1) mesa_id existe y no es vacío, 2) usuario no es vacío, 3) array votos es válido usando validateVotos. Retornar objeto {valid: boolean, errors: {field: message}} donde errors es un objeto con claves por cada campo inválido. Ejemplo: {valid: false, errors: {mesa_id: 'Mesa es requerida', usuario: 'Usuario es requerido', votos: 'Votos inválidos'}}. Usar validateRequerido y validateVotos internamente. Exportar todas las funciones del módulo.",
            "status": "done",
            "testStrategy": "Verificar que valida todos los campos requeridos, que retorna objeto errors con campos específicos, que integra correctamente validateVotos, que acepta telegramas válidos completos, y que puede ser usado en stores y componentes",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T01:44:37.512Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear utilidades de validación.",
        "updatedAt": "2025-12-12T01:44:37.512Z"
      },
      {
        "id": "28",
        "title": "Crear utilidades de formato y helpers",
        "description": "Implementar funciones auxiliares para formateo de números, fechas y descarga de archivos",
        "details": "Crear src/utils/formatters.js con: formatNumero(numero) usando Intl.NumberFormat('es-AR'), formatPorcentaje(valor, decimales), formatFecha(fecha) usando Intl.DateTimeFormat('es-AR'), formatHora(fecha). Crear src/utils/helpers.js con: downloadBlob(blob, filename) creando URL temporal y link de descarga, debounce(fn, delay) para optimizar búsquedas, groupBy(array, key) para agrupar datos, sortBy(array, key, order). Usar funciones nativas modernas de JavaScript (ES2020+).",
        "testStrategy": "Verificar que formatNumero formatea con separadores de miles, que formatPorcentaje muestra decimales correctos, que downloadBlob descarga archivos, y que debounce retrasa ejecución",
        "priority": "medium",
        "dependencies": [
          "8"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear archivo formatters.js con funciones de formato numérico y de fechas",
            "description": "Implementar funciones de formateo usando APIs de internacionalización nativas de JavaScript para números, porcentajes, fechas y horas",
            "dependencies": [],
            "details": "Crear src/utils/formatters.js exportando cuatro funciones: formatNumero(numero) usando new Intl.NumberFormat('es-AR', { minimumFractionDigits: 0 }).format(numero) para formatear con separadores de miles argentinos; formatPorcentaje(valor, decimales = 2) usando Intl.NumberFormat('es-AR', { style: 'percent', minimumFractionDigits: decimales, maximumFractionDigits: decimales }).format(valor / 100); formatFecha(fecha) convirtiendo fecha a Date si es string y usando new Intl.DateTimeFormat('es-AR', { day: '2-digit', month: '2-digit', year: 'numeric' }).format(fecha); formatHora(fecha) usando Intl.DateTimeFormat('es-AR', { hour: '2-digit', minute: '2-digit', second: '2-digit' }).format(fecha). Validar entradas y manejar valores null/undefined retornando string vacío o placeholder apropiado.",
            "status": "done",
            "testStrategy": "Verificar que formatNumero(1234567) retorna '1.234.567', que formatPorcentaje(45.67, 2) retorna '45,67%', que formatFecha acepta Date y strings ISO, que formatHora muestra formato 24h, y que valores inválidos retornan placeholders sin romper",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T01:50:41.008Z"
          },
          {
            "id": 2,
            "title": "Crear archivo helpers.js con utilidades de descarga y debounce",
            "description": "Implementar funciones auxiliares para descarga de archivos Blob y optimización de búsquedas con debounce",
            "dependencies": [],
            "details": "Crear src/utils/helpers.js con dos funciones: downloadBlob(blob, filename) que crea URL temporal con URL.createObjectURL(blob), genera elemento <a> con href al URL y download=filename, ejecuta click() programático, y limpia con URL.revokeObjectURL() en setTimeout; debounce(fn, delay = 300) retornando función wrapper que usa let timeoutId, clearTimeout(timeoutId) en cada llamada, y setTimeout(() => fn.apply(this, args), delay) para retrasar ejecución. Usar sintaxis de funciones flecha y desestructuración ES2020+. Agregar JSDoc comments explicando parámetros y retornos.",
            "status": "done",
            "testStrategy": "Verificar que downloadBlob genera descarga de archivo con nombre correcto (usar Blob de prueba), que debounce retrasa ejecución 300ms por defecto, que múltiples llamadas rápidas solo ejecutan la última, y que el contexto 'this' se preserva",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T01:50:41.097Z"
          },
          {
            "id": 3,
            "title": "Completar helpers.js con funciones de agrupamiento y ordenamiento",
            "description": "Implementar funciones utilitarias para agrupar arrays por clave y ordenar colecciones de objetos",
            "dependencies": [
              2
            ],
            "details": "Agregar a src/utils/helpers.js dos funciones: groupBy(array, key) usando array.reduce((acc, item) => { const grupo = item[key]; acc[grupo] = acc[grupo] || []; acc[grupo].push(item); return acc; }, {}) para agrupar objetos por valor de propiedad; sortBy(array, key, order = 'asc') creando copia con [...array] y usando .sort((a, b) => { const aVal = a[key]; const bVal = b[key]; if (order === 'asc') return aVal > bVal ? 1 : -1; return aVal < bVal ? 1 : -1; }) para ordenamiento configurable. Soportar ordenamiento de strings, números y fechas. Usar operador nullish coalescing (??) para valores por defecto. Exportar todas las funciones como named exports.",
            "status": "done",
            "testStrategy": "Verificar que groupBy([{tipo: 'A'}, {tipo: 'B'}, {tipo: 'A'}], 'tipo') retorna objeto con arrays agrupados, que sortBy ordena correctamente números ascendente/descendente, que sortBy maneja strings con localeCompare, y que no muta array original",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T01:50:41.175Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear utilidades de formato y helpers.",
        "updatedAt": "2025-12-12T01:50:41.175Z"
      },
      {
        "id": "29",
        "title": "Crear composable useApi para manejo de estados de peticiones",
        "description": "Implementar composable reutilizable para gestionar loading, data, error de llamadas API",
        "details": "Crear src/composables/useApi.js exportando función useApi(apiFunction) que retorna {data, loading, error, execute, reset}. Usar ref() para estados reactivos. execute() ejecuta apiFunction, setea loading=true, maneja resultado/error, setea loading=false. Patrón: const {data, loading, error, execute} = useApi(() => provinciaService.getAll()); await execute(). Soportar parámetros: useApi((id) => provinciaService.getById(id)); execute(1). Opción immediate para ejecutar automáticamente. Limpiar estado en onUnmounted si es necesario.",
        "testStrategy": "Verificar que loading cambia correctamente, que data se llena con resultado, que error captura excepciones, y que se puede reutilizar en múltiples componentes",
        "priority": "medium",
        "dependencies": [
          "4",
          "5"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base del composable useApi con estados reactivos",
            "description": "Implementar la estructura fundamental del composable useApi incluyendo todos los estados reactivos necesarios (data, loading, error) y la configuración inicial",
            "dependencies": [],
            "details": "Crear archivo src/composables/useApi.js. Implementar función useApi(apiFunction, options = {}) que acepta una función de API y opciones configurables. Declarar estados reactivos usando ref(): data (ref(null)), loading (ref(false)), error (ref(null)). Incluir opción 'immediate' en options para ejecutar automáticamente al montar. Estructurar el retorno del composable como objeto con {data, loading, error, execute, reset}. Preparar la base para la lógica de execute y reset que se implementará en subtareas posteriores.",
            "status": "pending",
            "testStrategy": "Verificar que el composable se importa correctamente, que data, loading y error son reactivos (ref), que acepta apiFunction como parámetro, y que retorna objeto con las propiedades esperadas",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar función execute para ejecutar peticiones API",
            "description": "Desarrollar la lógica principal de execute() que maneja el ciclo completo de una petición API incluyendo estados de carga, manejo de resultados y errores",
            "dependencies": [
              1
            ],
            "details": "Implementar función execute(...args) que acepta parámetros para pasar a apiFunction. Secuencia: setear loading.value = true, limpiar error.value = null, ejecutar try-catch con await apiFunction(...args), asignar resultado a data.value en caso de éxito, capturar excepciones y asignar a error.value, finalmente setear loading.value = false en bloque finally. Soportar paso de parámetros: execute(1) debe llamar apiFunction(1). Implementar lógica de immediate: si options.immediate === true, ejecutar execute() automáticamente al crear el composable usando onMounted si es necesario.",
            "status": "pending",
            "testStrategy": "Verificar que loading cambia a true durante ejecución y false al finalizar, que data se llena correctamente con el resultado de la API, que error captura excepciones y las almacena, que execute acepta parámetros y los pasa a apiFunction, y que immediate ejecuta automáticamente",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar función reset y limpieza de recursos",
            "description": "Crear función reset() para limpiar estados del composable y configurar limpieza automática de recursos al desmontar el componente",
            "dependencies": [
              2
            ],
            "details": "Implementar función reset() que restaura todos los estados a sus valores iniciales: data.value = null, loading.value = false, error.value = null. Usar onUnmounted de Vue para limpiar estado si es necesario cuando el componente se desmonta, evitando memory leaks. Exportar reset en el objeto de retorno del composable. Documentar con comentarios JSDoc el uso del composable con ejemplos: const {data, loading, error, execute} = useApi(() => provinciaService.getAll()); await execute(). Ejemplo con parámetros: useApi((id) => provinciaService.getById(id)); execute(1).",
            "status": "pending",
            "testStrategy": "Verificar que reset() limpia todos los estados correctamente (data=null, loading=false, error=null), que onUnmounted se ejecuta al desmontar el componente, que el composable es reutilizable en múltiples componentes sin conflictos, y que la documentación JSDoc está presente y correcta",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear composable useapi para manejo de estados de peticiones.",
        "updatedAt": "2025-12-12T02:45:23.601Z"
      },
      {
        "id": "30",
        "title": "Crear composable useForm para gestión de formularios",
        "description": "Implementar composable para manejar estado de formularios, validación y submissión",
        "details": "Crear src/composables/useForm.js exportando useForm({initialValues, validationSchema, onSubmit}). Retornar {values, errors, touched, isSubmitting, handleChange, handleSubmit, reset}. values es reactive() con campos del formulario. handleChange actualiza values y valida campo. handleSubmit previene default, valida todos, llama onSubmit si válido. validationSchema puede ser objeto de funciones de validators.js. Marcar touched al blur. Inspirado en formik/vee-validate pero más simple. Reutilizable en TelegramaForm y otros.",
        "testStrategy": "Verificar que values es reactivo, que validación se ejecuta al change, que errors se actualiza correctamente, que handleSubmit solo ejecuta si form válido, y que reset limpia formulario",
        "priority": "medium",
        "dependencies": [
          "27"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base del composable useForm",
            "description": "Implementar la función useForm con parámetros de entrada y estructura de retorno reactiva",
            "dependencies": [],
            "details": "Crear archivo src/composables/useForm.js. Exportar función useForm que recibe {initialValues, validationSchema, onSubmit}. Inicializar estado reactivo usando reactive() para values con initialValues. Crear refs para errors (objeto vacío), touched (objeto vacío), e isSubmitting (false). Estructurar el objeto de retorno con {values, errors, touched, isSubmitting, handleChange, handleSubmit, reset} (funciones serán implementadas en siguientes subtareas).",
            "status": "done",
            "testStrategy": "Verificar que useForm retorna todas las propiedades esperadas, que values es reactivo usando isReactive(), que errors y touched son objetos vacíos inicialmente, y que isSubmitting es false al inicio",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T01:55:40.595Z"
          },
          {
            "id": 2,
            "title": "Implementar funciones handleChange y validación de campos",
            "description": "Desarrollar la lógica de actualización de valores y validación individual de campos del formulario",
            "dependencies": [
              1
            ],
            "details": "Implementar función handleChange(fieldName, value) que actualiza values[fieldName] con el nuevo valor. Si existe validationSchema[fieldName], ejecutar la función validadora pasando el valor. Si la validación retorna error, agregar a errors[fieldName], sino limpiar el error. Implementar función handleBlur(fieldName) que marca touched[fieldName] = true. La validación debe ser sincrónica, retornando string de error o null/undefined si es válido. Usar funciones de src/utils/validators.js si está disponible.",
            "status": "done",
            "testStrategy": "Verificar que handleChange actualiza values correctamente, que la validación se ejecuta y errors se actualiza, que handleBlur marca campos como touched, y que validaciones inválidas muestran mensajes de error apropiados",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T01:55:40.669Z"
          },
          {
            "id": 3,
            "title": "Implementar handleSubmit y función reset",
            "description": "Crear la lógica de envío del formulario con validación completa y función de reseteo",
            "dependencies": [
              2
            ],
            "details": "Implementar handleSubmit que retorna una función async (event) que: 1) ejecuta event.preventDefault(), 2) marca isSubmitting = true, 3) valida todos los campos del validationSchema ejecutando cada validador, 4) si hay errores, actualiza objeto errors y setea isSubmitting = false sin llamar onSubmit, 5) si no hay errores, ejecuta await onSubmit(values), 6) finalmente setea isSubmitting = false en bloque finally. Implementar función reset() que restaura values a initialValues, limpia errors y touched, y setea isSubmitting a false. Inspirarse en patrones de formik/vee-validate pero mantenerlo simple.",
            "status": "done",
            "testStrategy": "Verificar que handleSubmit previene el comportamiento default del form, que valida todos los campos antes de enviar, que onSubmit solo se llama si el formulario es válido, que isSubmitting cambia correctamente durante el proceso, y que reset restaura el formulario a su estado inicial",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T01:55:40.758Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear composable useform para gestión de formularios.",
        "updatedAt": "2025-12-12T01:55:40.758Z"
      },
      {
        "id": "31",
        "title": "Implementar página Dashboard",
        "description": "Crear página principal con estadísticas, accesos rápidos y últimos telegramas según wireframe 5.3.1",
        "details": "Crear src/pages/DashboardPage.vue. Layout: AppHeader, contenido principal, AppFooter. Sección de StatsCards (3): Mesas Cargadas (icon: ClipboardDocumentCheck), Telegramas Pendientes (icon: DocumentText), Participación Nacional (icon: ChartBar). Sección Acciones Rápidas con 3 AppButtons: 'Cargar Telegrama' (router a /cargar-telegrama), 'Resultados Provincial', 'Exportar Reportes'. Tabla de Últimos Telegramas usando AppTable con columnas: Mesa, Provincia, Cargo, Usuario, Hora. Fetch datos de resultadoStore y telegramaStore en onMounted. Auto-refresh cada 30s opcional.",
        "testStrategy": "Verificar que las estadísticas muestran datos del backend, que los botones navegan correctamente, que la tabla de telegramas se actualiza, y que el layout es responsive",
        "priority": "high",
        "dependencies": [
          "17",
          "18",
          "19",
          "23",
          "26"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base de DashboardPage.vue con layout y secciones",
            "description": "Implementar el componente DashboardPage.vue con el layout completo incluyendo AppHeader, contenido principal y AppFooter. Crear las secciones principales: StatsCards, Acciones Rápidas y Últimos Telegramas.",
            "dependencies": [],
            "details": "Crear archivo src/pages/DashboardPage.vue. Importar y usar AppHeader y AppFooter. Estructurar el contenido principal en tres secciones usando divs semánticos con clases Tailwind: 1) Sección de estadísticas (grid de 3 columnas), 2) Sección de acciones rápidas (flex horizontal), 3) Sección de tabla de últimos telegramas. Aplicar estilos responsive con Tailwind CSS (mobile-first). Usar PageTitle para el título 'Dashboard'. Preparar refs vacíos para los datos (stats, ultimosTelegramas) que se llenarán en siguiente subtarea.",
            "status": "done",
            "testStrategy": "Verificar que el layout se renderiza correctamente con AppHeader y AppFooter, que las tres secciones están presentes en el DOM, y que el diseño es responsive en diferentes tamaños de pantalla",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T03:12:28.007Z"
          },
          {
            "id": 2,
            "title": "Implementar componentes StatsCards y botones de Acciones Rápidas",
            "description": "Crear y configurar los tres componentes StatsCard con sus respectivos íconos y datos, e implementar los tres AppButtons de acciones rápidas con navegación.",
            "dependencies": [
              1
            ],
            "details": "Importar íconos de Heroicons: ClipboardDocumentCheck, DocumentText, ChartBar. Crear 3 instancias de StatsCard con props: title ('Mesas Cargadas', 'Telegramas Pendientes', 'Participación Nacional'), value (ref desde stores), icon. Implementar 3 AppButtons: 'Cargar Telegrama' con @click que usa router.push('/cargar-telegrama'), 'Resultados Provincial' y 'Exportar Reportes' (funcionalidad placeholder). Organizar botones con gap y estilos consistentes. Conectar valores de stats a computed que lean de resultadoStore y telegramaStore.",
            "status": "done",
            "testStrategy": "Verificar que los tres StatsCards muestran los íconos correctos, que los valores se actualizan desde los stores, que el botón 'Cargar Telegrama' navega a /cargar-telegrama, y que todos los botones son clickeables",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T03:12:28.073Z"
          },
          {
            "id": 3,
            "title": "Implementar tabla de Últimos Telegramas con fetch de datos y auto-refresh",
            "description": "Configurar AppTable para mostrar los últimos telegramas con columnas especificadas, implementar fetch de datos en onMounted y configurar auto-refresh opcional cada 30 segundos.",
            "dependencies": [
              1,
              2
            ],
            "details": "Usar AppTable con configuración de columnas: Mesa (mesa.numero), Provincia (mesa.provincia.nombre), Cargo (cargo.nombre), Usuario (usuario.nombre), Hora (formatear timestamp). Crear computed ultimosTelegramas que obtenga datos de telegramaStore ordenados por fecha desc, limitados a últimos 10. En onMounted: llamar a telegramaStore.fetchTelegramas() y resultadoStore.fetchEstadisticas(). Implementar auto-refresh con setInterval cada 30000ms que vuelva a llamar fetch, guardando timer en ref. Limpiar interval en onBeforeUnmount. Manejar estados de loading y error con feedback visual.",
            "status": "done",
            "testStrategy": "Verificar que la tabla muestra los últimos telegramas con todas las columnas correctas, que los datos se cargan al montar el componente, que el auto-refresh actualiza la tabla cada 30 segundos, que el interval se limpia al desmontar, y que los estados de loading/error se muestran apropiadamente",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T03:12:28.160Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar página dashboard.",
        "updatedAt": "2025-12-12T03:12:28.160Z"
      },
      {
        "id": "32",
        "title": "Crear componente MesaSelector",
        "description": "Implementar selector de mesa con búsqueda y filtros por provincia",
        "details": "Crear src/components/forms/MesaSelector.vue. Props: modelValue (mesa seleccionada). Filtros: AppSelect de provincia, AppInput de búsqueda por ID. Al seleccionar provincia, fetch mesas de mesaStore.fetchMesasPorProvincia(). Búsqueda con debounce (useForm composable o manual). Mostrar resultados en lista (máx 10) con: número de mesa, escuela/circuito, electores habilitados. Click en resultado emite 'update:modelValue'. Mostrar badge de estado (cargada/pendiente). Loading state mientras fetch. Empty state si no hay resultados.",
        "testStrategy": "Verificar que filtro de provincia carga mesas, que búsqueda por ID filtra, que debounce optimiza, que selección emite evento correcto, y que loading/empty states funcionan",
        "priority": "high",
        "dependencies": [
          "11",
          "24"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base del componente MesaSelector con props y filtros",
            "description": "Crear el archivo src/components/forms/MesaSelector.vue con la estructura base del componente, definir las props necesarias (modelValue), e implementar los filtros de provincia y búsqueda por ID usando AppSelect y AppInput",
            "dependencies": [],
            "details": "Crear src/components/forms/MesaSelector.vue usando <script setup>. Definir props: modelValue (mesa seleccionada), opciones de configuración. Implementar layout con dos filtros en la parte superior: AppSelect para seleccionar provincia (usando provinciaStore para obtener listado) y AppInput para búsqueda por ID de mesa. Estructurar el template con contenedor principal, sección de filtros y área de resultados. Usar composables necesarios (ref, computed, watch). Establecer estado reactivo para provincia seleccionada y término de búsqueda. Aplicar estilos con Tailwind para layout responsive.",
            "status": "done",
            "testStrategy": "Verificar que el componente se renderiza correctamente, que AppSelect muestra el listado de provincias, que AppInput acepta entrada de texto, y que las props se reciben correctamente",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:18:51.418Z"
          },
          {
            "id": 2,
            "title": "Implementar lógica de búsqueda con debounce y fetch de mesas",
            "description": "Implementar la funcionalidad de búsqueda de mesas con debounce, integrar mesaStore.fetchMesasPorProvincia(), y gestionar los estados de loading y resultados",
            "dependencies": [
              1
            ],
            "details": "Importar mesaStore desde stores. Implementar función de debounce (300-500ms) para búsqueda por ID usando setTimeout o composable useDebounce. Al seleccionar provincia, ejecutar mesaStore.fetchMesasPorProvincia(provinciaId) automáticamente. Combinar resultados de filtro de provincia y búsqueda por ID. Limitar resultados mostrados a máximo 10 mesas. Gestionar estado loading con ref isLoading (true durante fetch, false al completar). Manejar errores con try-catch. Implementar estado computed para filteredMesas que aplica ambos filtros. Usar watch para reaccionar a cambios en provincia seleccionada.",
            "status": "done",
            "testStrategy": "Verificar que el debounce funciona correctamente (no hace fetch en cada tecla), que fetchMesasPorProvincia se ejecuta al seleccionar provincia, que los resultados se limitan a 10, que el estado loading se actualiza correctamente, y que la búsqueda combina ambos filtros",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:18:51.424Z"
          },
          {
            "id": 3,
            "title": "Renderizar lista de resultados con estados y funcionalidad de selección",
            "description": "Implementar la visualización de la lista de mesas con información detallada, badges de estado, manejo de eventos de selección, y estados de loading/empty",
            "dependencies": [
              2
            ],
            "details": "Crear lista de resultados mostrando para cada mesa: número de mesa (destacado), nombre de escuela/circuito, cantidad de electores habilitados. Implementar AppBadge para mostrar estado de mesa (cargada en success, pendiente en warning). Añadir evento @click en cada item que emite 'update:modelValue' con mesa seleccionada. Implementar loading state: mostrar AppSpinner o skeleton mientras isLoading=true. Implementar empty state: mensaje 'No se encontraron mesas' cuando filteredMesas.length === 0 y no está loading. Aplicar estilos hover en items de lista, cursor pointer. Usar transition-group para animación suave de lista. Destacar visualmente la mesa actualmente seleccionada (modelValue). Asegurar accesibilidad con roles ARIA apropiados.",
            "status": "done",
            "testStrategy": "Verificar que la lista muestra correctamente número, escuela y electores, que los badges muestran el estado correcto (cargada/pendiente), que el click emite update:modelValue con la mesa correcta, que el loading state muestra spinner, que el empty state aparece cuando no hay resultados, y que la mesa seleccionada se destaca visualmente",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:18:51.432Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear componente mesaselector.",
        "updatedAt": "2025-12-12T02:18:51.432Z"
      },
      {
        "id": "33",
        "title": "Crear componente VotosInput",
        "description": "Implementar input especializado para votos con validación numérica",
        "details": "Crear src/components/forms/VotosInput.vue extendiendo AppInput. Props adicionales: max (electores para validación). Type fijo 'number', min='0', step='1'. Validación en tiempo real: >= 0, entero, <= max si definido. Mostrar error visual si inválido. Evento @input para actualización inmediata. Prevenir input de caracteres no numéricos con @keypress. Formateo visual con separadores de miles al blur (opcional). Estilos destacados (font-mono para números, text-right alignment).",
        "testStrategy": "Verificar que solo acepta números positivos enteros, que valida contra max, que previene caracteres inválidos, y que v-model actualiza correctamente",
        "priority": "medium",
        "dependencies": [
          "10"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base del componente VotosInput.vue",
            "description": "Implementar la estructura básica del componente extendiendo AppInput con props específicas para validación de votos",
            "dependencies": [],
            "details": "Crear archivo src/components/forms/VotosInput.vue con <script setup>. Definir props: modelValue (number), max (number, opcional para validar contra electores), label, error, disabled. Heredar de AppInput configurando type='number', min='0', step='1' como valores fijos. Implementar v-model bidireccional con defineModel() o emit('update:modelValue'). Añadir clases CSS base: font-mono para números, text-right para alineación. Estructura template con slot para label y mensaje de error.",
            "status": "done",
            "testStrategy": "Verificar que el componente se renderiza correctamente, que hereda props de AppInput, que acepta modelValue numérico, y que aplica estilos monospace y text-right",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:07:15.531Z"
          },
          {
            "id": 2,
            "title": "Implementar validación en tiempo real y prevención de caracteres inválidos",
            "description": "Añadir lógica de validación numérica y manejo de eventos para prevenir input no válido",
            "dependencies": [
              1
            ],
            "details": "Implementar handler @keypress que prevenga caracteres no numéricos (solo permitir dígitos 0-9). Crear computed o watcher para validación en tiempo real: verificar que valor >= 0, que sea entero (Number.isInteger), que sea <= max si prop max está definida. Mantener estado reactivo 'isValid' basado en validaciones. Emitir evento @input inmediatamente al cambiar valor para actualización en tiempo real. Aplicar clases condicionales para estado de error visual (border-red, text-red) cuando isValid=false. Generar mensaje de error descriptivo según tipo de validación fallida.",
            "status": "done",
            "testStrategy": "Verificar que keypress bloquea letras y símbolos, que validación detecta números negativos y decimales, que valida correctamente contra prop max, que muestra error visual cuando inválido, y que evento @input se emite inmediatamente",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:07:15.536Z"
          },
          {
            "id": 3,
            "title": "Añadir formateo visual con separadores de miles al perder foco",
            "description": "Implementar formateo opcional de números con separadores de miles en evento blur",
            "dependencies": [
              2
            ],
            "details": "Implementar handler @blur que formatee el valor numérico con separadores de miles usando Intl.NumberFormat o función custom formatNumero (si existe en utils). Mantener valor interno sin formato para v-model (solo números), pero mostrar versión formateada visualmente. Al hacer @focus, remover formateo para edición. Ejemplo: 1000000 → '1.000.000' al blur. Asegurar que formateo no interfiera con validación ni v-model. El formateo es opcional y puramente visual (no afecta el valor emitido). Aplicar transición suave al cambiar entre formato/sin formato.",
            "status": "done",
            "testStrategy": "Verificar que al hacer blur el número muestra separadores de miles, que al focus vuelve a número sin formato, que v-model mantiene valor numérico correcto, que formateo no rompe validación, y que funciona con números grandes",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:07:15.546Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear componente votosinput.",
        "updatedAt": "2025-12-12T02:07:15.546Z"
      },
      {
        "id": "34",
        "title": "Crear componente TelegramaForm",
        "description": "Implementar formulario completo de carga de telegrama con validación en tiempo real según wireframe 5.3.2",
        "details": "Crear src/components/forms/TelegramaForm.vue usando useForm composable. Props: mesa (objeto mesa seleccionada). Mostrar info de mesa: número, electores. Sección votos por lista: iterar listas de la provincia, dos VotosInput por lista (Diputados, Senadores). Sección otros votos: inputs para Blancos, Nulos, Recurridos. Cálculo automático de total votos (computed). Validación en tiempo real: total <= electores, mostrar diferencia (abstenciones), indicador visual (AppAlert) si válido/inválido. Botones: Cancelar (router.back), Guardar (disabled si inválido). onSubmit llama telegramaStore.guardarTelegrama(), muestra toast de resultado, limpia form si success.",
        "testStrategy": "Verificar que validación en tiempo real funciona, que total se calcula correctamente, que botón guardar se deshabilita si inválido, que errores del backend se muestran, y que success limpia form y muestra toast",
        "priority": "high",
        "dependencies": [
          "32",
          "33",
          "25",
          "30"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base del componente TelegramaForm.vue",
            "description": "Implementar la estructura base del componente con props, sección de información de mesa y esqueleto de secciones de votos",
            "dependencies": [],
            "details": "Crear archivo src/components/forms/TelegramaForm.vue con <script setup>. Definir prop 'mesa' (objeto con número, electores, provincia). Importar useForm composable desde src/composables/useForm.js. Inicializar formulario con campos: votosPorLista (object), blancos (0), nulos (0), recurridos (0). Crear sección visual de información de mesa mostrando número y total de electores habilitados. Definir estructura HTML con secciones: info mesa, votos por lista (placeholder), otros votos (placeholder), totales y validación (placeholder), botones (placeholder). Importar componentes necesarios: VotosInput, AppAlert, AppButton. Configurar emit 'submit' para comunicación con componente padre.",
            "status": "pending",
            "testStrategy": "Verificar que el componente se renderiza correctamente, que recibe la prop mesa, que muestra la información de mesa (número y electores), y que la estructura base del formulario existe",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar secciones de votos con VotosInput y validación en tiempo real",
            "description": "Desarrollar la sección de votos por lista iterando las listas de la provincia, sección de otros votos, y cálculo automático del total con validación",
            "dependencies": [
              1
            ],
            "details": "Obtener listas de la provincia desde mesa.provincia o store correspondiente. Iterar listas y renderizar dos VotosInput por cada una: uno para Diputados y otro para Senadores, usando v-model con votosPorLista[lista.id][cargo]. Implementar sección 'Otros Votos' con tres VotosInput: Blancos, Nulos, Recurridos vinculados con v-model. Crear computed 'totalVotos' que suma todos los votos (por lista + blancos + nulos + recurridos). Crear computed 'abstenciones' que calcula mesa.electores - totalVotos. Crear computed 'esValido' que retorna true si totalVotos <= mesa.electores. Implementar AppAlert que muestra mensaje visual: success si esValido=true mostrando abstenciones, error si esValido=false mostrando exceso de votos. Actualizar validación en tiempo real usando watchers o computed properties.",
            "status": "pending",
            "testStrategy": "Verificar que se iteran correctamente las listas de la provincia, que cada lista muestra dos VotosInput (Diputados/Senadores), que los inputs de otros votos funcionan, que totalVotos se calcula correctamente al cambiar cualquier valor, que abstenciones se muestran cuando total < electores, y que AppAlert refleja el estado de validación",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar botones de acción y método onSubmit con integración al store",
            "description": "Desarrollar botones Cancelar y Guardar con lógica de submit, integración con telegramaStore, manejo de errores y limpieza del formulario",
            "dependencies": [
              2
            ],
            "details": "Importar telegramaStore desde src/stores/telegrama.js y useRouter/useToast. Crear método onSubmit async que: construye objeto telegrama con { mesaId, votosPorLista, blancos, nulos, recurridos }, llama await telegramaStore.guardarTelegrama(telegrama), maneja errores con try/catch mostrando toast de error, en caso de éxito muestra toast success y resetea el formulario usando resetForm() del composable. Implementar botón 'Cancelar' que ejecuta router.back() al hacer click. Implementar botón 'Guardar' de tipo submit con :disabled='!esValido || isSubmitting', conectado al evento @submit.prevent del form. Añadir estado isSubmitting para prevenir doble submit. Usar AppButton con variant='primary' para Guardar y variant='secondary' para Cancelar. Mostrar loading en botón Guardar durante submit.",
            "status": "pending",
            "testStrategy": "Verificar que botón Cancelar navega hacia atrás, que botón Guardar está deshabilitado cuando esValido=false, que al hacer submit se llama telegramaStore.guardarTelegrama con datos correctos, que errores del backend se muestran en toast, que éxito muestra toast y limpia el formulario, y que no se puede hacer doble submit",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear componente telegramaform.",
        "updatedAt": "2025-12-12T02:22:47.959Z"
      },
      {
        "id": "35",
        "title": "Implementar página CargaTelegrama",
        "description": "Crear página de carga de telegramas integrando MesaSelector y TelegramaForm según wireframe 5.3.2",
        "details": "Crear src/pages/CargaTelegramaPage.vue. Layout: AppHeader, breadcrumb/back button, contenido, AppFooter. Flujo: 1) Mostrar MesaSelector, 2) Al seleccionar mesa, mostrar TelegramaForm con mesa prop, 3) Después de guardar con éxito, volver a paso 1 para siguiente telegrama. Usar ref mesaSeleccionada. Transición suave entre pasos (Transition component). Mostrar PageTitle 'Carga de Telegrama'. Manejar navegación: botón 'Volver' a dashboard. Persistir última provincia seleccionada en sessionStorage para agilizar carga sucesiva.",
        "testStrategy": "Verificar que flujo completo funciona (seleccionar mesa → cargar votos → guardar → resetear), que transiciones son fluidas, que volver al dashboard funciona, y que sessionStorage persiste provincia",
        "priority": "high",
        "dependencies": [
          "34",
          "17",
          "18"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base de CargaTelegramaPage.vue",
            "description": "Implementar el componente Vue con layout completo, navegación y estructura de dos pasos",
            "dependencies": [],
            "details": "Crear archivo src/pages/CargaTelegramaPage.vue. Importar AppHeader, AppFooter, PageTitle. Definir ref mesaSeleccionada (null inicialmente) para controlar qué paso mostrar. Implementar breadcrumb/botón 'Volver' que navegue a /dashboard usando useRouter(). Mostrar PageTitle con texto 'Carga de Telegrama'. Estructurar template con AppHeader arriba, contenedor principal en el medio, y AppFooter abajo. Preparar lógica para mostrar condicionalmente MesaSelector cuando mesaSeleccionada === null, y TelegramaForm cuando mesaSeleccionada !== null.",
            "status": "pending",
            "testStrategy": "Verificar que la página renderiza correctamente con AppHeader y AppFooter, que el botón 'Volver' navega al dashboard, y que PageTitle muestra el texto correcto",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Integrar MesaSelector y flujo de selección con persistencia",
            "description": "Implementar paso 1 del flujo: mostrar MesaSelector y manejar evento de selección con sessionStorage",
            "dependencies": [
              1
            ],
            "details": "Importar componente MesaSelector (de task 34). Renderizar MesaSelector cuando mesaSeleccionada ref === null. Escuchar evento @mesa-selected y actualizar mesaSeleccionada.value con la mesa recibida. Implementar persistencia de última provincia seleccionada: en onMounted, leer 'ultimaProvincia' de sessionStorage y pasarla como prop inicial a MesaSelector. Al recibir selección, guardar provincia en sessionStorage.setItem('ultimaProvincia', mesa.provinciaId). Envolver cambio de paso en Transition component de Vue para transición suave entre MesaSelector y TelegramaForm.",
            "status": "pending",
            "testStrategy": "Verificar que MesaSelector se muestra inicialmente, que al seleccionar una mesa se actualiza mesaSeleccionada, que sessionStorage persiste la provincia seleccionada entre recargas, y que la transición es fluida",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrar TelegramaForm y flujo de guardado exitoso",
            "description": "Implementar paso 2 del flujo: mostrar TelegramaForm con mesa seleccionada y resetear al guardar",
            "dependencies": [
              2
            ],
            "details": "Importar componente TelegramaForm (de task 17/18). Renderizar TelegramaForm cuando mesaSeleccionada !== null, pasando :mesa='mesaSeleccionada' como prop. Escuchar evento @telegrama-guardado emitido por TelegramaForm tras guardado exitoso. Al recibir evento, ejecutar mesaSeleccionada.value = null para volver al paso 1 (MesaSelector). Aplicar Transition component para transición suave al resetear. Opcional: mostrar notificación de éxito breve antes de resetear usando composable de notificaciones si existe (o setTimeout simple).",
            "status": "pending",
            "testStrategy": "Verificar que TelegramaForm se muestra al seleccionar mesa con los datos correctos, que después de guardar exitosamente se vuelve automáticamente a MesaSelector, que la transición de vuelta es fluida, y que se puede cargar un nuevo telegrama inmediatamente",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar página cargatelegrama.",
        "updatedAt": "2025-12-12T03:02:18.867Z"
      },
      {
        "id": "36",
        "title": "Crear componente ResultadosListaTable",
        "description": "Implementar tabla de resultados por lista con votos, porcentajes y ranking",
        "details": "Crear src/components/tables/ResultadosListaTable.vue extendiendo AppTable. Columnas: Posición (emoji 🥇🥈🥉 para top 3), Lista (nombre + alianza), Votos (formateado con separadores), Porcentaje (barra visual + número), Estado (badge). Props: listas (array ordenado por votos desc), cargo. Renderizar barra de porcentaje con div bg gradient proporcional al %. Usar AppBadge para estado (1° Lugar en success, etc). Slot personalizado para celda de votos (formatNumero). Ordenamiento por votos descendente por default. Mostrar totales en footer: blancos, nulos, recurridos con porcentajes.",
        "testStrategy": "Verificar que listas se ordenan por votos, que porcentajes calculan correctamente, que barras visuales son proporcionales, que badges muestran posición, y que footer suma totales",
        "priority": "high",
        "dependencies": [
          "14",
          "15",
          "28"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base del componente ResultadosListaTable.vue",
            "description": "Implementar la estructura básica del componente extendiendo AppTable con las props necesarias y la configuración de columnas",
            "dependencies": [],
            "details": "Crear archivo src/components/tables/ResultadosListaTable.vue con <script setup>. Definir props: listas (array de resultados ordenados por votos descendente) y cargo (string). Extender o usar AppTable como base. Configurar columnas: Posición, Lista, Votos, Porcentaje, Estado. Implementar computed para procesar datos de entrada. Definir estructura del template con AppTable y sus slots correspondientes. Preparar la lógica para ordenamiento por votos descendente como default.",
            "status": "done",
            "testStrategy": "Verificar que el componente se monta correctamente, que recibe las props esperadas, que AppTable se renderiza, y que la estructura de columnas está definida",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:41:53.255Z"
          },
          {
            "id": 2,
            "title": "Implementar renderizado de columnas con formato personalizado",
            "description": "Desarrollar las celdas personalizadas para Posición (emojis), Lista (nombre + alianza), Votos (formateados), Porcentaje (barra visual) y Estado (badge)",
            "dependencies": [
              1
            ],
            "details": "Columna Posición: renderizar emojis 🥇🥈🥉 para top 3 usando condicional basado en índice. Columna Lista: mostrar nombre de lista y alianza (si existe) con estilos diferenciados. Columna Votos: usar slot personalizado con función formatNumero para separadores de miles. Columna Porcentaje: crear barra visual con <div> que tenga background gradient proporcional al porcentaje, mostrar número al lado. Columna Estado: usar AppBadge con variant dinámico (success para 1° lugar, etc.) basado en posición. Implementar lógica de cálculo de porcentajes si no viene en datos.",
            "status": "done",
            "testStrategy": "Verificar que emojis aparecen solo en top 3, que votos tienen separadores correctos, que barras de porcentaje son proporcionales a los valores, que badges muestran variante correcta según posición, y que alianzas se muestran cuando existen",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:41:53.342Z"
          },
          {
            "id": 3,
            "title": "Agregar footer con totales de votos blancos, nulos y recurridos",
            "description": "Implementar sección de footer en la tabla mostrando totales y porcentajes de votos blancos, nulos y recurridos",
            "dependencies": [
              2
            ],
            "details": "Crear slot de footer en AppTable o sección dedicada después de la tabla. Calcular totales: blancos, nulos, recurridos usando datos de prop listas o props adicionales. Calcular porcentaje de cada categoría respecto al total de votos. Renderizar footer con estructura de 3 columnas mostrando: tipo de voto, cantidad formateada (con formatNumero), porcentaje. Aplicar estilos diferenciados para footer (bg gris claro, font-weight medium). Asegurar que los totales se actualicen reactivamente si cambian las listas.",
            "status": "done",
            "testStrategy": "Verificar que footer se renderiza correctamente, que totales suman correctamente, que porcentajes calculan bien respecto al total, que formato de números es consistente con el resto de la tabla, y que se actualiza reactivamente",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T02:41:53.429Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear componente resultadoslistatable.",
        "updatedAt": "2025-12-12T02:41:53.429Z"
      },
      {
        "id": "37",
        "title": "Implementar páginas ResultadosProvincial y ResultadosNacional",
        "description": "Crear páginas de visualización de resultados según wireframes 5.3.3 y 5.3.4",
        "details": "Crear src/pages/ResultadosProvincialPage.vue: Filtros AppSelect (Provincia, Cargo), AppCard de resumen (mesas escrutadas %, participación %, votos válidos), ResultadosListaTable, botón Exportar CSV (llama importExportService.exportProvincial, downloadBlob). Fetch de resultadoStore.fetchResultadoProvincial al cambiar filtros. Crear src/pages/ResultadosNacionalPage.vue: Filtro Cargo, tabla nacional con ranking de listas (votos, %, provincias), tabla de participación por provincia (AppTable con columnas: Provincia, Mesas totales, Escrutadas %, Participación %), botón Exportar. Fetch resultadoStore.fetchResultadoNacional. Usar watchers para refetch al cambiar cargo.",
        "testStrategy": "Verificar que filtros cargan datos correctos, que tablas se renderizan con datos del backend, que exportar descarga CSV, y que cambiar cargo actualiza resultados",
        "priority": "high",
        "dependencies": [
          "36",
          "26",
          "17",
          "18"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar ResultadosProvincialPage.vue con filtros y resumen",
            "description": "Crear página de resultados provinciales con filtros de provincia y cargo, card de resumen con estadísticas de escrutinio y participación, y tabla de resultados por lista",
            "dependencies": [],
            "details": "Crear src/pages/ResultadosProvincialPage.vue con layout completo (AppHeader, contenido, AppFooter). Implementar filtros usando AppSelect para Provincia y Cargo en la parte superior. Crear AppCard de resumen mostrando: mesas escrutadas (%), participación (%), votos válidos. Integrar ResultadosListaTable para mostrar ranking de listas con votos y porcentajes. Implementar watchers en filtros (provincia, cargo) que llamen a resultadoStore.fetchResultadoProvincial(provinciaId, cargoId) automáticamente. Manejar estados de loading y error. Usar computed properties para calcular estadísticas del resumen a partir de datos del store. Aplicar estilos responsive según design system.",
            "status": "pending",
            "testStrategy": "Verificar que los filtros cargan opciones correctamente desde provinciaStore y cargoStore, que al cambiar filtros se dispara fetchResultadoProvincial, que el card de resumen muestra estadísticas actualizadas, que ResultadosListaTable renderiza datos del store, y que la página es responsive",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar ResultadosNacionalPage.vue con tablas de ranking y participación",
            "description": "Crear página de resultados nacionales con filtro de cargo, tabla de ranking nacional de listas y tabla de participación por provincia",
            "dependencies": [],
            "details": "Crear src/pages/ResultadosNacionalPage.vue con layout completo. Implementar filtro AppSelect solo para Cargo. Crear tabla nacional de ranking usando AppTable con columnas: Posición, Lista, Votos totales, Porcentaje, Provincias ganadas. Crear segunda tabla de participación por provincia con AppTable mostrando columnas: Provincia, Mesas totales, Escrutadas (%), Participación (%). Implementar watcher en cargo que llame a resultadoStore.fetchResultadoNacional(cargoId). Usar computed properties para procesar datos del store y calcular rankings. Aplicar ordenamiento descendente por votos en tabla de ranking. Manejar estados de loading/error con AppLoading y mensajes apropiados.",
            "status": "pending",
            "testStrategy": "Verificar que fetchResultadoNacional se dispara al montar componente y al cambiar cargo, que tabla de ranking ordena correctamente por votos, que tabla de participación muestra datos de todas las provincias, que porcentajes se calculan correctamente, y que loading states funcionan",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar funcionalidad de exportación CSV en ambas páginas",
            "description": "Agregar botones de exportación CSV que utilicen importExportService y downloadBlob para descargar datos de resultados provinciales y nacionales",
            "dependencies": [
              1,
              2
            ],
            "details": "En ResultadosProvincialPage.vue: agregar AppButton 'Exportar CSV' que al hacer click llame a importExportService.exportProvincial(provinciaId, cargoId), obtenga el blob de respuesta y use downloadBlob(blob, 'resultados-provincial-{provincia}-{cargo}.csv'). En ResultadosNacionalPage.vue: agregar AppButton 'Exportar CSV' que llame a importExportService.exportNacional(cargoId) y descargue como 'resultados-nacional-{cargo}.csv'. Implementar manejo de errores con try/catch mostrando notificación de error si falla. Agregar estado loading en botones durante exportación (disabled + spinner). Posicionar botones en esquina superior derecha de cada sección de resultados. Validar que haya datos antes de permitir exportación.",
            "status": "pending",
            "testStrategy": "Verificar que click en Exportar descarga archivo CSV con nombre correcto, que botón se deshabilita durante exportación, que errores de red muestran notificación apropiada, que CSV contiene datos correctos según filtros seleccionados, y que no se puede exportar si no hay datos cargados",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar páginas resultadosprovincial y resultadosnacional.",
        "updatedAt": "2025-12-12T03:08:57.131Z"
      },
      {
        "id": "38",
        "title": "Crear componente FileUploader e implementar página Configuración",
        "description": "Implementar componente de upload de archivos CSV y página de configuración según wireframe 5.3.5",
        "details": "Crear src/components/forms/FileUploader.vue. Props: accept (default '.csv'), multiple (boolean). Área drag & drop con @drop, @dragover, @dragleave. Input file oculto activado por click en área. Mostrar nombre de archivo seleccionado. Emit 'upload' con File object. Estados: idle, dragover, uploading (AppSpinner), success, error. Crear src/pages/ConfiguracionPage.vue: AppSelect tipo de datos (Provincias, Listas, Mesas, Telegramas), FileUploader, botón Importar (llama importExportService según tipo), AppModal mostrando resultado de importación (éxitos, errores). Sección Gestión de Catálogos con tabs o botones a futuras vistas de edición (puede quedar como placeholder).",
        "testStrategy": "Verificar que drag & drop funciona, que upload emite evento correcto, que importación llama servicio adecuado, que resultado se muestra en modal, y que estados visuales son claros",
        "priority": "medium",
        "dependencies": [
          "12",
          "22",
          "17",
          "18"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar componente FileUploader.vue con drag & drop",
            "description": "Crear componente reutilizable de carga de archivos con soporte para drag & drop, validación de tipos de archivo y gestión de estados visuales",
            "dependencies": [],
            "details": "Crear src/components/forms/FileUploader.vue con script setup. Props: accept (string, default '.csv'), multiple (boolean, default false). Implementar área de drop zone con eventos @drop.prevent, @dragover.prevent, @dragleave. Crear input file oculto (ref) activado por @click en área visual. Gestionar estados reactivos: idle, dragover (resaltar borde), uploading (mostrar AppSpinner), success, error. Mostrar nombre(s) de archivo seleccionado con icono de documento. Emitir evento 'upload' con File object(s). Estilos: borde punteado en idle, borde sólido primary en dragover, bg-gray-50 hover. Usar transiciones para cambios de estado. Validar tipo de archivo contra prop accept antes de emitir.",
            "status": "done",
            "testStrategy": "Verificar que drag & drop cambia estado visual, que click activa input file, que solo acepta archivos del tipo especificado, que evento 'upload' emite File correcto, que estados loading/success/error se muestran apropiadamente, y que multiple files funciona si prop múltiple es true",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T03:14:39.326Z"
          },
          {
            "id": 2,
            "title": "Crear página ConfiguracionPage.vue con selector de tipo y preview de importación",
            "description": "Implementar vista de configuración con selector de tipo de datos, integración de FileUploader y modal de resultados de importación",
            "dependencies": [
              1
            ],
            "details": "Crear src/pages/ConfiguracionPage.vue con composables necesarios (ref, computed). Layout con AppContainer. Sección principal: título 'Importación de Datos', AppSelect con options tipo de datos (value: 'provincias'|'listas'|'mesas'|'telegramas', label visible). Integrar FileUploader con @upload handler. Botón AppButton 'Importar Datos' variant='primary' :disabled si no hay archivo seleccionado. Handler de importación: determinar método de importExportService según tipo seleccionado (importarProvincias, importarListas, etc), ejecutar con try/catch, mostrar AppSpinner durante proceso. Integrar AppModal para mostrar resultado con título dinámico, lista de éxitos (AppAlert success), lista de errores (AppAlert error), contador de registros procesados. Sección secundaria 'Gestión de Catálogos' con tabs placeholder (usar AppTabs si existe o divs con botones) para futuras vistas de edición.",
            "status": "done",
            "testStrategy": "Verificar que selector de tipo muestra opciones correctas, que FileUploader se integra y emite archivo, que botón Importar está deshabilitado sin archivo, que llamada a importExportService usa método correcto según tipo, que modal muestra resultados de importación con formato correcto, y que estados de loading se gestionan durante el proceso",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T03:15:19.500Z"
          },
          {
            "id": 3,
            "title": "Implementar lógica de importación y manejo de errores en ConfiguracionPage",
            "description": "Desarrollar la lógica de procesamiento de archivos CSV, validación de datos y retroalimentación de errores al usuario",
            "dependencies": [
              1,
              2
            ],
            "details": "En ConfiguracionPage.vue, crear método handleImport que recibe File de FileUploader. Usar importExportService con mapeo: tipo='provincias' → importarProvincias(file), 'listas' → importarListas(file), 'mesas' → importarMesas(file), 'telegramas' → importarTelegramas(file). Implementar try/catch: en try setear estado uploading en FileUploader, ejecutar import, guardar resultado {success: number, errors: Array<{row, message}>}. En catch mostrar AppAlert error genérico. Preparar datos para AppModal: calcular total procesado, formatear lista de errores con número de fila y mensaje, agrupar éxitos. Implementar reset después de cerrar modal: limpiar archivo seleccionado, resetear tipo a default, cerrar modal. Añadir validación básica de formato CSV antes de enviar (verificar extensión .csv, tamaño máximo opcional). Gestionar estados reactivos: showModal, importResult, isImporting.",
            "status": "done",
            "testStrategy": "Verificar que archivo CSV válido se procesa correctamente, que errores de formato se capturan y muestran en modal, que servicio correcto se llama según tipo seleccionado, que contadores de éxito/error son precisos, que modal se cierra y resetea estado, que validaciones previas al import funcionan, y que mensajes de error son informativos para el usuario",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T03:15:26.969Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear componente fileuploader e implementar página configuración.",
        "updatedAt": "2025-12-12T03:15:26.969Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-12T03:17:16.107Z",
      "taskCount": 38,
      "completedCount": 38,
      "tags": [
        "master"
      ]
    }
  }
}